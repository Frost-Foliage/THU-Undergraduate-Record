Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program_component -> function
Rule 2     program_component -> declaration Semi
Rule 3     program_component -> program_component program_component
Rule 4     empty -> <empty>
Rule 5     program -> program_component
Rule 6     type -> Int
Rule 7     function -> type Identifier LParen Parameter RParen LBrace block RBrace
Rule 8     block -> block block_item
Rule 9     block -> empty
Rule 10    block_item -> statement
Rule 11    block_item -> declaration Semi
Rule 12    statement -> statement_matched
Rule 13    statement -> statement_unmatched
Rule 14    statement_matched -> If LParen expression RParen statement_matched Else statement_matched
Rule 15    statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched
Rule 16    statement_unmatched -> If LParen expression RParen statement
Rule 17    statement_matched -> While LParen expression RParen statement_matched
Rule 18    statement_unmatched -> While LParen expression RParen statement_unmatched
Rule 19    statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
Rule 20    statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched
Rule 21    statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched
Rule 22    statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched
Rule 23    statement_matched -> Do statement_matched While LParen expression RParen Semi
Rule 24    statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi
Rule 25    statement_matched -> Return expression Semi
Rule 26    statement_matched -> opt_expression Semi
Rule 27    statement_matched -> LBrace block RBrace
Rule 28    statement_matched -> Break Semi
Rule 29    statement_matched -> Continue Semi
Rule 30    opt_expression -> expression
Rule 31    opt_expression -> empty
Rule 32    declaration -> type Identifier
Rule 33    declaration -> type Identifier Assign expression
Rule 34    arr_dim_list -> LBracket Integer RBracket arr_dim_list
Rule 35    arr_dim_list -> LBracket Integer RBracket
Rule 36    declaration -> type Identifier arr_dim_list
Rule 37    postfix -> Identifier LParen call_para RParen
Rule 38    call_para -> expression
Rule 39    call_para -> empty
Rule 40    call_para -> call_para Comma call_para
Rule 41    Parameter -> type Identifier
Rule 42    Parameter -> Parameter Comma Parameter
Rule 43    Parameter -> empty
Rule 44    expression -> assignment
Rule 45    assignment -> conditional
Rule 46    conditional -> logical_or
Rule 47    logical_or -> logical_and
Rule 48    logical_and -> bit_or
Rule 49    bit_or -> xor
Rule 50    xor -> bit_and
Rule 51    bit_and -> equality
Rule 52    equality -> relational
Rule 53    relational -> additive
Rule 54    additive -> multiplicative
Rule 55    multiplicative -> unary
Rule 56    unary -> postfix
Rule 57    postfix -> primary
Rule 58    unary -> Minus unary
Rule 59    unary -> BitNot unary
Rule 60    unary -> Not unary
Rule 61    arr_idx_list -> LBracket expression RBracket arr_idx_list
Rule 62    arr_idx_list -> LBracket expression RBracket
Rule 63    arr_ref -> Identifier arr_idx_list
Rule 64    assignment -> Identifier Assign expression
Rule 65    assignment -> arr_ref Assign expression
Rule 66    logical_or -> logical_or Or logical_and
Rule 67    logical_and -> logical_and And bit_or
Rule 68    bit_or -> bit_or BitOr xor
Rule 69    xor -> xor Xor bit_and
Rule 70    bit_and -> bit_and BitAnd equality
Rule 71    equality -> equality NotEqual relational
Rule 72    equality -> equality Equal relational
Rule 73    relational -> relational Less additive
Rule 74    relational -> relational Greater additive
Rule 75    relational -> relational LessEqual additive
Rule 76    relational -> relational GreaterEqual additive
Rule 77    additive -> additive Plus multiplicative
Rule 78    additive -> additive Minus multiplicative
Rule 79    multiplicative -> multiplicative Mul unary
Rule 80    multiplicative -> multiplicative Div unary
Rule 81    multiplicative -> multiplicative Mod unary
Rule 82    conditional -> logical_or Question expression Colon conditional
Rule 83    primary -> Integer
Rule 84    primary -> Identifier
Rule 85    primary -> LParen expression RParen
Rule 86    primary -> arr_ref

Terminals, with rules where they appear

And                  : 67
Assign               : 33 64 65
BitAnd               : 70
BitNot               : 59
BitOr                : 68
Break                : 28
Colon                : 82
Comma                : 40 42
Continue             : 29
Div                  : 80
Do                   : 23 24
Else                 : 14 15
Equal                : 72
For                  : 19 20 21 22
Greater              : 74
GreaterEqual         : 76
Identifier           : 7 32 33 36 37 41 63 64 84
If                   : 14 15 16
Int                  : 6
Integer              : 34 35 83
LBrace               : 7 27
LBracket             : 34 35 61 62
LParen               : 7 14 15 16 17 18 19 20 21 22 23 24 37 85
Less                 : 73
LessEqual            : 75
Minus                : 58 78
Mod                  : 81
Mul                  : 79
Not                  : 60
NotEqual             : 71
Or                   : 66
Plus                 : 77
Question             : 82
RBrace               : 7 27
RBracket             : 34 35 61 62
RParen               : 7 14 15 16 17 18 19 20 21 22 23 24 37 85
Return               : 25
Semi                 : 2 11 19 19 20 20 21 21 22 22 23 24 25 26 28 29
While                : 17 18 23 24
Xor                  : 69
error                : 

Nonterminals, with rules where they appear

Parameter            : 7 42 42
additive             : 53 73 74 75 76 77 78
arr_dim_list         : 34 36
arr_idx_list         : 61 63
arr_ref              : 65 86
assignment           : 44
bit_and              : 50 69 70
bit_or               : 48 67 68
block                : 7 8 27
block_item           : 8
call_para            : 37 40 40
conditional          : 45 82
declaration          : 2 11 20 22
empty                : 9 31 39 43
equality             : 51 70 71 72
expression           : 14 15 16 17 18 23 24 25 30 33 38 61 62 64 65 82 85
function             : 1
logical_and          : 47 66 67
logical_or           : 46 66 82
multiplicative       : 54 77 78 79 80 81
opt_expression       : 19 19 19 20 20 21 21 21 22 22 26
postfix              : 56
primary              : 57
program              : 0
program_component    : 3 3 5
relational           : 52 71 72 73 74 75 76
statement            : 10 16
statement_matched    : 12 14 14 15 17 19 20 23
statement_unmatched  : 13 15 18 21 22 24
type                 : 7 32 33 36 41
unary                : 55 58 59 60 79 80 81
xor                  : 49 68 69

Parsing method: LALR

state 0

    (0) S' -> . program
    (5) program -> . program_component
    (1) program_component -> . function
    (2) program_component -> . declaration Semi
    (3) program_component -> . program_component program_component
    (7) function -> . type Identifier LParen Parameter RParen LBrace block RBrace
    (32) declaration -> . type Identifier
    (33) declaration -> . type Identifier Assign expression
    (36) declaration -> . type Identifier arr_dim_list
    (6) type -> . Int

    Int             shift and go to state 6

    program                        shift and go to state 1
    program_component              shift and go to state 2
    function                       shift and go to state 3
    declaration                    shift and go to state 4
    type                           shift and go to state 5

state 1

    (0) S' -> program .



state 2

    (5) program -> program_component .
    (3) program_component -> program_component . program_component
    (1) program_component -> . function
    (2) program_component -> . declaration Semi
    (3) program_component -> . program_component program_component
    (7) function -> . type Identifier LParen Parameter RParen LBrace block RBrace
    (32) declaration -> . type Identifier
    (33) declaration -> . type Identifier Assign expression
    (36) declaration -> . type Identifier arr_dim_list
    (6) type -> . Int

    $end            reduce using rule 5 (program -> program_component .)
    Int             shift and go to state 6

    program_component              shift and go to state 7
    function                       shift and go to state 3
    declaration                    shift and go to state 4
    type                           shift and go to state 5

state 3

    (1) program_component -> function .

    Int             reduce using rule 1 (program_component -> function .)
    $end            reduce using rule 1 (program_component -> function .)


state 4

    (2) program_component -> declaration . Semi

    Semi            shift and go to state 8


state 5

    (7) function -> type . Identifier LParen Parameter RParen LBrace block RBrace
    (32) declaration -> type . Identifier
    (33) declaration -> type . Identifier Assign expression
    (36) declaration -> type . Identifier arr_dim_list

    Identifier      shift and go to state 9


state 6

    (6) type -> Int .

    Identifier      reduce using rule 6 (type -> Int .)


state 7

    (3) program_component -> program_component program_component .
    (3) program_component -> program_component . program_component
    (1) program_component -> . function
    (2) program_component -> . declaration Semi
    (3) program_component -> . program_component program_component
    (7) function -> . type Identifier LParen Parameter RParen LBrace block RBrace
    (32) declaration -> . type Identifier
    (33) declaration -> . type Identifier Assign expression
    (36) declaration -> . type Identifier arr_dim_list
    (6) type -> . Int

  ! shift/reduce conflict for Int resolved as shift
    $end            reduce using rule 3 (program_component -> program_component program_component .)
    Int             shift and go to state 6

  ! Int             [ reduce using rule 3 (program_component -> program_component program_component .) ]

    program_component              shift and go to state 7
    function                       shift and go to state 3
    declaration                    shift and go to state 4
    type                           shift and go to state 5

state 8

    (2) program_component -> declaration Semi .

    Int             reduce using rule 2 (program_component -> declaration Semi .)
    $end            reduce using rule 2 (program_component -> declaration Semi .)


state 9

    (7) function -> type Identifier . LParen Parameter RParen LBrace block RBrace
    (32) declaration -> type Identifier .
    (33) declaration -> type Identifier . Assign expression
    (36) declaration -> type Identifier . arr_dim_list
    (34) arr_dim_list -> . LBracket Integer RBracket arr_dim_list
    (35) arr_dim_list -> . LBracket Integer RBracket

    LParen          shift and go to state 10
    Semi            reduce using rule 32 (declaration -> type Identifier .)
    Assign          shift and go to state 11
    LBracket        shift and go to state 13

    arr_dim_list                   shift and go to state 12

state 10

    (7) function -> type Identifier LParen . Parameter RParen LBrace block RBrace
    (41) Parameter -> . type Identifier
    (42) Parameter -> . Parameter Comma Parameter
    (43) Parameter -> . empty
    (6) type -> . Int
    (4) empty -> .

    Int             shift and go to state 6
    RParen          reduce using rule 4 (empty -> .)
    Comma           reduce using rule 4 (empty -> .)

    type                           shift and go to state 14
    Parameter                      shift and go to state 15
    empty                          shift and go to state 16

state 11

    (33) declaration -> type Identifier Assign . expression
    (44) expression -> . assignment
    (45) assignment -> . conditional
    (64) assignment -> . Identifier Assign expression
    (65) assignment -> . arr_ref Assign expression
    (46) conditional -> . logical_or
    (82) conditional -> . logical_or Question expression Colon conditional
    (63) arr_ref -> . Identifier arr_idx_list
    (47) logical_or -> . logical_and
    (66) logical_or -> . logical_or Or logical_and
    (48) logical_and -> . bit_or
    (67) logical_and -> . logical_and And bit_or
    (49) bit_or -> . xor
    (68) bit_or -> . bit_or BitOr xor
    (50) xor -> . bit_and
    (69) xor -> . xor Xor bit_and
    (51) bit_and -> . equality
    (70) bit_and -> . bit_and BitAnd equality
    (52) equality -> . relational
    (71) equality -> . equality NotEqual relational
    (72) equality -> . equality Equal relational
    (53) relational -> . additive
    (73) relational -> . relational Less additive
    (74) relational -> . relational Greater additive
    (75) relational -> . relational LessEqual additive
    (76) relational -> . relational GreaterEqual additive
    (54) additive -> . multiplicative
    (77) additive -> . additive Plus multiplicative
    (78) additive -> . additive Minus multiplicative
    (55) multiplicative -> . unary
    (79) multiplicative -> . multiplicative Mul unary
    (80) multiplicative -> . multiplicative Div unary
    (81) multiplicative -> . multiplicative Mod unary
    (56) unary -> . postfix
    (58) unary -> . Minus unary
    (59) unary -> . BitNot unary
    (60) unary -> . Not unary
    (37) postfix -> . Identifier LParen call_para RParen
    (57) postfix -> . primary
    (83) primary -> . Integer
    (84) primary -> . Identifier
    (85) primary -> . LParen expression RParen
    (86) primary -> . arr_ref

    Identifier      shift and go to state 17
    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Integer         shift and go to state 38
    LParen          shift and go to state 36

    expression                     shift and go to state 18
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    arr_ref                        shift and go to state 21
    logical_or                     shift and go to state 22
    logical_and                    shift and go to state 23
    bit_or                         shift and go to state 24
    xor                            shift and go to state 25
    bit_and                        shift and go to state 26
    equality                       shift and go to state 27
    relational                     shift and go to state 28
    additive                       shift and go to state 29
    multiplicative                 shift and go to state 30
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 37

state 12

    (36) declaration -> type Identifier arr_dim_list .

    Semi            reduce using rule 36 (declaration -> type Identifier arr_dim_list .)


state 13

    (34) arr_dim_list -> LBracket . Integer RBracket arr_dim_list
    (35) arr_dim_list -> LBracket . Integer RBracket

    Integer         shift and go to state 39


state 14

    (41) Parameter -> type . Identifier

    Identifier      shift and go to state 40


state 15

    (7) function -> type Identifier LParen Parameter . RParen LBrace block RBrace
    (42) Parameter -> Parameter . Comma Parameter

    RParen          shift and go to state 41
    Comma           shift and go to state 42


state 16

    (43) Parameter -> empty .

    RParen          reduce using rule 43 (Parameter -> empty .)
    Comma           reduce using rule 43 (Parameter -> empty .)


state 17

    (64) assignment -> Identifier . Assign expression
    (63) arr_ref -> Identifier . arr_idx_list
    (37) postfix -> Identifier . LParen call_para RParen
    (84) primary -> Identifier .
    (61) arr_idx_list -> . LBracket expression RBracket arr_idx_list
    (62) arr_idx_list -> . LBracket expression RBracket

    Assign          shift and go to state 43
    LParen          shift and go to state 45
    Mul             reduce using rule 84 (primary -> Identifier .)
    Div             reduce using rule 84 (primary -> Identifier .)
    Mod             reduce using rule 84 (primary -> Identifier .)
    Plus            reduce using rule 84 (primary -> Identifier .)
    Minus           reduce using rule 84 (primary -> Identifier .)
    Less            reduce using rule 84 (primary -> Identifier .)
    Greater         reduce using rule 84 (primary -> Identifier .)
    LessEqual       reduce using rule 84 (primary -> Identifier .)
    GreaterEqual    reduce using rule 84 (primary -> Identifier .)
    NotEqual        reduce using rule 84 (primary -> Identifier .)
    Equal           reduce using rule 84 (primary -> Identifier .)
    BitAnd          reduce using rule 84 (primary -> Identifier .)
    Xor             reduce using rule 84 (primary -> Identifier .)
    BitOr           reduce using rule 84 (primary -> Identifier .)
    And             reduce using rule 84 (primary -> Identifier .)
    Question        reduce using rule 84 (primary -> Identifier .)
    Or              reduce using rule 84 (primary -> Identifier .)
    Semi            reduce using rule 84 (primary -> Identifier .)
    RParen          reduce using rule 84 (primary -> Identifier .)
    Comma           reduce using rule 84 (primary -> Identifier .)
    RBracket        reduce using rule 84 (primary -> Identifier .)
    Colon           reduce using rule 84 (primary -> Identifier .)
    LBracket        shift and go to state 46

    arr_idx_list                   shift and go to state 44

state 18

    (33) declaration -> type Identifier Assign expression .

    Semi            reduce using rule 33 (declaration -> type Identifier Assign expression .)


state 19

    (44) expression -> assignment .

    Semi            reduce using rule 44 (expression -> assignment .)
    RParen          reduce using rule 44 (expression -> assignment .)
    Comma           reduce using rule 44 (expression -> assignment .)
    RBracket        reduce using rule 44 (expression -> assignment .)
    Colon           reduce using rule 44 (expression -> assignment .)


state 20

    (45) assignment -> conditional .

    Semi            reduce using rule 45 (assignment -> conditional .)
    RParen          reduce using rule 45 (assignment -> conditional .)
    Comma           reduce using rule 45 (assignment -> conditional .)
    RBracket        reduce using rule 45 (assignment -> conditional .)
    Colon           reduce using rule 45 (assignment -> conditional .)


state 21

    (65) assignment -> arr_ref . Assign expression
    (86) primary -> arr_ref .

    Assign          shift and go to state 47
    Mul             reduce using rule 86 (primary -> arr_ref .)
    Div             reduce using rule 86 (primary -> arr_ref .)
    Mod             reduce using rule 86 (primary -> arr_ref .)
    Plus            reduce using rule 86 (primary -> arr_ref .)
    Minus           reduce using rule 86 (primary -> arr_ref .)
    Less            reduce using rule 86 (primary -> arr_ref .)
    Greater         reduce using rule 86 (primary -> arr_ref .)
    LessEqual       reduce using rule 86 (primary -> arr_ref .)
    GreaterEqual    reduce using rule 86 (primary -> arr_ref .)
    NotEqual        reduce using rule 86 (primary -> arr_ref .)
    Equal           reduce using rule 86 (primary -> arr_ref .)
    BitAnd          reduce using rule 86 (primary -> arr_ref .)
    Xor             reduce using rule 86 (primary -> arr_ref .)
    BitOr           reduce using rule 86 (primary -> arr_ref .)
    And             reduce using rule 86 (primary -> arr_ref .)
    Question        reduce using rule 86 (primary -> arr_ref .)
    Or              reduce using rule 86 (primary -> arr_ref .)
    Semi            reduce using rule 86 (primary -> arr_ref .)
    RParen          reduce using rule 86 (primary -> arr_ref .)
    Comma           reduce using rule 86 (primary -> arr_ref .)
    RBracket        reduce using rule 86 (primary -> arr_ref .)
    Colon           reduce using rule 86 (primary -> arr_ref .)


state 22

    (46) conditional -> logical_or .
    (82) conditional -> logical_or . Question expression Colon conditional
    (66) logical_or -> logical_or . Or logical_and

    Semi            reduce using rule 46 (conditional -> logical_or .)
    RParen          reduce using rule 46 (conditional -> logical_or .)
    Comma           reduce using rule 46 (conditional -> logical_or .)
    RBracket        reduce using rule 46 (conditional -> logical_or .)
    Colon           reduce using rule 46 (conditional -> logical_or .)
    Question        shift and go to state 48
    Or              shift and go to state 49


state 23

    (47) logical_or -> logical_and .
    (67) logical_and -> logical_and . And bit_or

    Question        reduce using rule 47 (logical_or -> logical_and .)
    Or              reduce using rule 47 (logical_or -> logical_and .)
    Semi            reduce using rule 47 (logical_or -> logical_and .)
    RParen          reduce using rule 47 (logical_or -> logical_and .)
    Comma           reduce using rule 47 (logical_or -> logical_and .)
    RBracket        reduce using rule 47 (logical_or -> logical_and .)
    Colon           reduce using rule 47 (logical_or -> logical_and .)
    And             shift and go to state 50


state 24

    (48) logical_and -> bit_or .
    (68) bit_or -> bit_or . BitOr xor

    And             reduce using rule 48 (logical_and -> bit_or .)
    Question        reduce using rule 48 (logical_and -> bit_or .)
    Or              reduce using rule 48 (logical_and -> bit_or .)
    Semi            reduce using rule 48 (logical_and -> bit_or .)
    RParen          reduce using rule 48 (logical_and -> bit_or .)
    Comma           reduce using rule 48 (logical_and -> bit_or .)
    RBracket        reduce using rule 48 (logical_and -> bit_or .)
    Colon           reduce using rule 48 (logical_and -> bit_or .)
    BitOr           shift and go to state 51


state 25

    (49) bit_or -> xor .
    (69) xor -> xor . Xor bit_and

    BitOr           reduce using rule 49 (bit_or -> xor .)
    And             reduce using rule 49 (bit_or -> xor .)
    Question        reduce using rule 49 (bit_or -> xor .)
    Or              reduce using rule 49 (bit_or -> xor .)
    Semi            reduce using rule 49 (bit_or -> xor .)
    RParen          reduce using rule 49 (bit_or -> xor .)
    Comma           reduce using rule 49 (bit_or -> xor .)
    RBracket        reduce using rule 49 (bit_or -> xor .)
    Colon           reduce using rule 49 (bit_or -> xor .)
    Xor             shift and go to state 52


state 26

    (50) xor -> bit_and .
    (70) bit_and -> bit_and . BitAnd equality

    Xor             reduce using rule 50 (xor -> bit_and .)
    BitOr           reduce using rule 50 (xor -> bit_and .)
    And             reduce using rule 50 (xor -> bit_and .)
    Question        reduce using rule 50 (xor -> bit_and .)
    Or              reduce using rule 50 (xor -> bit_and .)
    Semi            reduce using rule 50 (xor -> bit_and .)
    RParen          reduce using rule 50 (xor -> bit_and .)
    Comma           reduce using rule 50 (xor -> bit_and .)
    RBracket        reduce using rule 50 (xor -> bit_and .)
    Colon           reduce using rule 50 (xor -> bit_and .)
    BitAnd          shift and go to state 53


state 27

    (51) bit_and -> equality .
    (71) equality -> equality . NotEqual relational
    (72) equality -> equality . Equal relational

    BitAnd          reduce using rule 51 (bit_and -> equality .)
    Xor             reduce using rule 51 (bit_and -> equality .)
    BitOr           reduce using rule 51 (bit_and -> equality .)
    And             reduce using rule 51 (bit_and -> equality .)
    Question        reduce using rule 51 (bit_and -> equality .)
    Or              reduce using rule 51 (bit_and -> equality .)
    Semi            reduce using rule 51 (bit_and -> equality .)
    RParen          reduce using rule 51 (bit_and -> equality .)
    Comma           reduce using rule 51 (bit_and -> equality .)
    RBracket        reduce using rule 51 (bit_and -> equality .)
    Colon           reduce using rule 51 (bit_and -> equality .)
    NotEqual        shift and go to state 54
    Equal           shift and go to state 55


state 28

    (52) equality -> relational .
    (73) relational -> relational . Less additive
    (74) relational -> relational . Greater additive
    (75) relational -> relational . LessEqual additive
    (76) relational -> relational . GreaterEqual additive

    NotEqual        reduce using rule 52 (equality -> relational .)
    Equal           reduce using rule 52 (equality -> relational .)
    BitAnd          reduce using rule 52 (equality -> relational .)
    Xor             reduce using rule 52 (equality -> relational .)
    BitOr           reduce using rule 52 (equality -> relational .)
    And             reduce using rule 52 (equality -> relational .)
    Question        reduce using rule 52 (equality -> relational .)
    Or              reduce using rule 52 (equality -> relational .)
    Semi            reduce using rule 52 (equality -> relational .)
    RParen          reduce using rule 52 (equality -> relational .)
    Comma           reduce using rule 52 (equality -> relational .)
    RBracket        reduce using rule 52 (equality -> relational .)
    Colon           reduce using rule 52 (equality -> relational .)
    Less            shift and go to state 56
    Greater         shift and go to state 57
    LessEqual       shift and go to state 58
    GreaterEqual    shift and go to state 59


state 29

    (53) relational -> additive .
    (77) additive -> additive . Plus multiplicative
    (78) additive -> additive . Minus multiplicative

    Less            reduce using rule 53 (relational -> additive .)
    Greater         reduce using rule 53 (relational -> additive .)
    LessEqual       reduce using rule 53 (relational -> additive .)
    GreaterEqual    reduce using rule 53 (relational -> additive .)
    NotEqual        reduce using rule 53 (relational -> additive .)
    Equal           reduce using rule 53 (relational -> additive .)
    BitAnd          reduce using rule 53 (relational -> additive .)
    Xor             reduce using rule 53 (relational -> additive .)
    BitOr           reduce using rule 53 (relational -> additive .)
    And             reduce using rule 53 (relational -> additive .)
    Question        reduce using rule 53 (relational -> additive .)
    Or              reduce using rule 53 (relational -> additive .)
    Semi            reduce using rule 53 (relational -> additive .)
    RParen          reduce using rule 53 (relational -> additive .)
    Comma           reduce using rule 53 (relational -> additive .)
    RBracket        reduce using rule 53 (relational -> additive .)
    Colon           reduce using rule 53 (relational -> additive .)
    Plus            shift and go to state 60
    Minus           shift and go to state 61


state 30

    (54) additive -> multiplicative .
    (79) multiplicative -> multiplicative . Mul unary
    (80) multiplicative -> multiplicative . Div unary
    (81) multiplicative -> multiplicative . Mod unary

    Plus            reduce using rule 54 (additive -> multiplicative .)
    Minus           reduce using rule 54 (additive -> multiplicative .)
    Less            reduce using rule 54 (additive -> multiplicative .)
    Greater         reduce using rule 54 (additive -> multiplicative .)
    LessEqual       reduce using rule 54 (additive -> multiplicative .)
    GreaterEqual    reduce using rule 54 (additive -> multiplicative .)
    NotEqual        reduce using rule 54 (additive -> multiplicative .)
    Equal           reduce using rule 54 (additive -> multiplicative .)
    BitAnd          reduce using rule 54 (additive -> multiplicative .)
    Xor             reduce using rule 54 (additive -> multiplicative .)
    BitOr           reduce using rule 54 (additive -> multiplicative .)
    And             reduce using rule 54 (additive -> multiplicative .)
    Question        reduce using rule 54 (additive -> multiplicative .)
    Or              reduce using rule 54 (additive -> multiplicative .)
    Semi            reduce using rule 54 (additive -> multiplicative .)
    RParen          reduce using rule 54 (additive -> multiplicative .)
    Comma           reduce using rule 54 (additive -> multiplicative .)
    RBracket        reduce using rule 54 (additive -> multiplicative .)
    Colon           reduce using rule 54 (additive -> multiplicative .)
    Mul             shift and go to state 62
    Div             shift and go to state 63
    Mod             shift and go to state 64


state 31

    (58) unary -> Minus . unary
    (56) unary -> . postfix
    (58) unary -> . Minus unary
    (59) unary -> . BitNot unary
    (60) unary -> . Not unary
    (37) postfix -> . Identifier LParen call_para RParen
    (57) postfix -> . primary
    (83) primary -> . Integer
    (84) primary -> . Identifier
    (85) primary -> . LParen expression RParen
    (86) primary -> . arr_ref
    (63) arr_ref -> . Identifier arr_idx_list

    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Identifier      shift and go to state 66
    Integer         shift and go to state 38
    LParen          shift and go to state 36

    unary                          shift and go to state 65
    postfix                        shift and go to state 33
    primary                        shift and go to state 37
    arr_ref                        shift and go to state 67

state 32

    (55) multiplicative -> unary .

    Mul             reduce using rule 55 (multiplicative -> unary .)
    Div             reduce using rule 55 (multiplicative -> unary .)
    Mod             reduce using rule 55 (multiplicative -> unary .)
    Plus            reduce using rule 55 (multiplicative -> unary .)
    Minus           reduce using rule 55 (multiplicative -> unary .)
    Less            reduce using rule 55 (multiplicative -> unary .)
    Greater         reduce using rule 55 (multiplicative -> unary .)
    LessEqual       reduce using rule 55 (multiplicative -> unary .)
    GreaterEqual    reduce using rule 55 (multiplicative -> unary .)
    NotEqual        reduce using rule 55 (multiplicative -> unary .)
    Equal           reduce using rule 55 (multiplicative -> unary .)
    BitAnd          reduce using rule 55 (multiplicative -> unary .)
    Xor             reduce using rule 55 (multiplicative -> unary .)
    BitOr           reduce using rule 55 (multiplicative -> unary .)
    And             reduce using rule 55 (multiplicative -> unary .)
    Question        reduce using rule 55 (multiplicative -> unary .)
    Or              reduce using rule 55 (multiplicative -> unary .)
    Semi            reduce using rule 55 (multiplicative -> unary .)
    RParen          reduce using rule 55 (multiplicative -> unary .)
    Comma           reduce using rule 55 (multiplicative -> unary .)
    RBracket        reduce using rule 55 (multiplicative -> unary .)
    Colon           reduce using rule 55 (multiplicative -> unary .)


state 33

    (56) unary -> postfix .

    Mul             reduce using rule 56 (unary -> postfix .)
    Div             reduce using rule 56 (unary -> postfix .)
    Mod             reduce using rule 56 (unary -> postfix .)
    Plus            reduce using rule 56 (unary -> postfix .)
    Minus           reduce using rule 56 (unary -> postfix .)
    Less            reduce using rule 56 (unary -> postfix .)
    Greater         reduce using rule 56 (unary -> postfix .)
    LessEqual       reduce using rule 56 (unary -> postfix .)
    GreaterEqual    reduce using rule 56 (unary -> postfix .)
    NotEqual        reduce using rule 56 (unary -> postfix .)
    Equal           reduce using rule 56 (unary -> postfix .)
    BitAnd          reduce using rule 56 (unary -> postfix .)
    Xor             reduce using rule 56 (unary -> postfix .)
    BitOr           reduce using rule 56 (unary -> postfix .)
    And             reduce using rule 56 (unary -> postfix .)
    Question        reduce using rule 56 (unary -> postfix .)
    Or              reduce using rule 56 (unary -> postfix .)
    Semi            reduce using rule 56 (unary -> postfix .)
    RParen          reduce using rule 56 (unary -> postfix .)
    Comma           reduce using rule 56 (unary -> postfix .)
    RBracket        reduce using rule 56 (unary -> postfix .)
    Colon           reduce using rule 56 (unary -> postfix .)


state 34

    (59) unary -> BitNot . unary
    (56) unary -> . postfix
    (58) unary -> . Minus unary
    (59) unary -> . BitNot unary
    (60) unary -> . Not unary
    (37) postfix -> . Identifier LParen call_para RParen
    (57) postfix -> . primary
    (83) primary -> . Integer
    (84) primary -> . Identifier
    (85) primary -> . LParen expression RParen
    (86) primary -> . arr_ref
    (63) arr_ref -> . Identifier arr_idx_list

    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Identifier      shift and go to state 66
    Integer         shift and go to state 38
    LParen          shift and go to state 36

    unary                          shift and go to state 68
    postfix                        shift and go to state 33
    primary                        shift and go to state 37
    arr_ref                        shift and go to state 67

state 35

    (60) unary -> Not . unary
    (56) unary -> . postfix
    (58) unary -> . Minus unary
    (59) unary -> . BitNot unary
    (60) unary -> . Not unary
    (37) postfix -> . Identifier LParen call_para RParen
    (57) postfix -> . primary
    (83) primary -> . Integer
    (84) primary -> . Identifier
    (85) primary -> . LParen expression RParen
    (86) primary -> . arr_ref
    (63) arr_ref -> . Identifier arr_idx_list

    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Identifier      shift and go to state 66
    Integer         shift and go to state 38
    LParen          shift and go to state 36

    unary                          shift and go to state 69
    postfix                        shift and go to state 33
    primary                        shift and go to state 37
    arr_ref                        shift and go to state 67

state 36

    (85) primary -> LParen . expression RParen
    (44) expression -> . assignment
    (45) assignment -> . conditional
    (64) assignment -> . Identifier Assign expression
    (65) assignment -> . arr_ref Assign expression
    (46) conditional -> . logical_or
    (82) conditional -> . logical_or Question expression Colon conditional
    (63) arr_ref -> . Identifier arr_idx_list
    (47) logical_or -> . logical_and
    (66) logical_or -> . logical_or Or logical_and
    (48) logical_and -> . bit_or
    (67) logical_and -> . logical_and And bit_or
    (49) bit_or -> . xor
    (68) bit_or -> . bit_or BitOr xor
    (50) xor -> . bit_and
    (69) xor -> . xor Xor bit_and
    (51) bit_and -> . equality
    (70) bit_and -> . bit_and BitAnd equality
    (52) equality -> . relational
    (71) equality -> . equality NotEqual relational
    (72) equality -> . equality Equal relational
    (53) relational -> . additive
    (73) relational -> . relational Less additive
    (74) relational -> . relational Greater additive
    (75) relational -> . relational LessEqual additive
    (76) relational -> . relational GreaterEqual additive
    (54) additive -> . multiplicative
    (77) additive -> . additive Plus multiplicative
    (78) additive -> . additive Minus multiplicative
    (55) multiplicative -> . unary
    (79) multiplicative -> . multiplicative Mul unary
    (80) multiplicative -> . multiplicative Div unary
    (81) multiplicative -> . multiplicative Mod unary
    (56) unary -> . postfix
    (58) unary -> . Minus unary
    (59) unary -> . BitNot unary
    (60) unary -> . Not unary
    (37) postfix -> . Identifier LParen call_para RParen
    (57) postfix -> . primary
    (83) primary -> . Integer
    (84) primary -> . Identifier
    (85) primary -> . LParen expression RParen
    (86) primary -> . arr_ref

    Identifier      shift and go to state 17
    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Integer         shift and go to state 38
    LParen          shift and go to state 36

    expression                     shift and go to state 70
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    arr_ref                        shift and go to state 21
    logical_or                     shift and go to state 22
    logical_and                    shift and go to state 23
    bit_or                         shift and go to state 24
    xor                            shift and go to state 25
    bit_and                        shift and go to state 26
    equality                       shift and go to state 27
    relational                     shift and go to state 28
    additive                       shift and go to state 29
    multiplicative                 shift and go to state 30
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 37

state 37

    (57) postfix -> primary .

    Mul             reduce using rule 57 (postfix -> primary .)
    Div             reduce using rule 57 (postfix -> primary .)
    Mod             reduce using rule 57 (postfix -> primary .)
    Plus            reduce using rule 57 (postfix -> primary .)
    Minus           reduce using rule 57 (postfix -> primary .)
    Less            reduce using rule 57 (postfix -> primary .)
    Greater         reduce using rule 57 (postfix -> primary .)
    LessEqual       reduce using rule 57 (postfix -> primary .)
    GreaterEqual    reduce using rule 57 (postfix -> primary .)
    NotEqual        reduce using rule 57 (postfix -> primary .)
    Equal           reduce using rule 57 (postfix -> primary .)
    BitAnd          reduce using rule 57 (postfix -> primary .)
    Xor             reduce using rule 57 (postfix -> primary .)
    BitOr           reduce using rule 57 (postfix -> primary .)
    And             reduce using rule 57 (postfix -> primary .)
    Question        reduce using rule 57 (postfix -> primary .)
    Or              reduce using rule 57 (postfix -> primary .)
    Semi            reduce using rule 57 (postfix -> primary .)
    RParen          reduce using rule 57 (postfix -> primary .)
    Comma           reduce using rule 57 (postfix -> primary .)
    RBracket        reduce using rule 57 (postfix -> primary .)
    Colon           reduce using rule 57 (postfix -> primary .)


state 38

    (83) primary -> Integer .

    Mul             reduce using rule 83 (primary -> Integer .)
    Div             reduce using rule 83 (primary -> Integer .)
    Mod             reduce using rule 83 (primary -> Integer .)
    Plus            reduce using rule 83 (primary -> Integer .)
    Minus           reduce using rule 83 (primary -> Integer .)
    Less            reduce using rule 83 (primary -> Integer .)
    Greater         reduce using rule 83 (primary -> Integer .)
    LessEqual       reduce using rule 83 (primary -> Integer .)
    GreaterEqual    reduce using rule 83 (primary -> Integer .)
    NotEqual        reduce using rule 83 (primary -> Integer .)
    Equal           reduce using rule 83 (primary -> Integer .)
    BitAnd          reduce using rule 83 (primary -> Integer .)
    Xor             reduce using rule 83 (primary -> Integer .)
    BitOr           reduce using rule 83 (primary -> Integer .)
    And             reduce using rule 83 (primary -> Integer .)
    Question        reduce using rule 83 (primary -> Integer .)
    Or              reduce using rule 83 (primary -> Integer .)
    Semi            reduce using rule 83 (primary -> Integer .)
    RParen          reduce using rule 83 (primary -> Integer .)
    Comma           reduce using rule 83 (primary -> Integer .)
    RBracket        reduce using rule 83 (primary -> Integer .)
    Colon           reduce using rule 83 (primary -> Integer .)


state 39

    (34) arr_dim_list -> LBracket Integer . RBracket arr_dim_list
    (35) arr_dim_list -> LBracket Integer . RBracket

    RBracket        shift and go to state 71


state 40

    (41) Parameter -> type Identifier .

    RParen          reduce using rule 41 (Parameter -> type Identifier .)
    Comma           reduce using rule 41 (Parameter -> type Identifier .)


state 41

    (7) function -> type Identifier LParen Parameter RParen . LBrace block RBrace

    LBrace          shift and go to state 72


state 42

    (42) Parameter -> Parameter Comma . Parameter
    (41) Parameter -> . type Identifier
    (42) Parameter -> . Parameter Comma Parameter
    (43) Parameter -> . empty
    (6) type -> . Int
    (4) empty -> .

    Int             shift and go to state 6
    Comma           reduce using rule 4 (empty -> .)
    RParen          reduce using rule 4 (empty -> .)

    Parameter                      shift and go to state 73
    type                           shift and go to state 14
    empty                          shift and go to state 16

state 43

    (64) assignment -> Identifier Assign . expression
    (44) expression -> . assignment
    (45) assignment -> . conditional
    (64) assignment -> . Identifier Assign expression
    (65) assignment -> . arr_ref Assign expression
    (46) conditional -> . logical_or
    (82) conditional -> . logical_or Question expression Colon conditional
    (63) arr_ref -> . Identifier arr_idx_list
    (47) logical_or -> . logical_and
    (66) logical_or -> . logical_or Or logical_and
    (48) logical_and -> . bit_or
    (67) logical_and -> . logical_and And bit_or
    (49) bit_or -> . xor
    (68) bit_or -> . bit_or BitOr xor
    (50) xor -> . bit_and
    (69) xor -> . xor Xor bit_and
    (51) bit_and -> . equality
    (70) bit_and -> . bit_and BitAnd equality
    (52) equality -> . relational
    (71) equality -> . equality NotEqual relational
    (72) equality -> . equality Equal relational
    (53) relational -> . additive
    (73) relational -> . relational Less additive
    (74) relational -> . relational Greater additive
    (75) relational -> . relational LessEqual additive
    (76) relational -> . relational GreaterEqual additive
    (54) additive -> . multiplicative
    (77) additive -> . additive Plus multiplicative
    (78) additive -> . additive Minus multiplicative
    (55) multiplicative -> . unary
    (79) multiplicative -> . multiplicative Mul unary
    (80) multiplicative -> . multiplicative Div unary
    (81) multiplicative -> . multiplicative Mod unary
    (56) unary -> . postfix
    (58) unary -> . Minus unary
    (59) unary -> . BitNot unary
    (60) unary -> . Not unary
    (37) postfix -> . Identifier LParen call_para RParen
    (57) postfix -> . primary
    (83) primary -> . Integer
    (84) primary -> . Identifier
    (85) primary -> . LParen expression RParen
    (86) primary -> . arr_ref

    Identifier      shift and go to state 17
    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Integer         shift and go to state 38
    LParen          shift and go to state 36

    expression                     shift and go to state 74
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    arr_ref                        shift and go to state 21
    logical_or                     shift and go to state 22
    logical_and                    shift and go to state 23
    bit_or                         shift and go to state 24
    xor                            shift and go to state 25
    bit_and                        shift and go to state 26
    equality                       shift and go to state 27
    relational                     shift and go to state 28
    additive                       shift and go to state 29
    multiplicative                 shift and go to state 30
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 37

state 44

    (63) arr_ref -> Identifier arr_idx_list .

    Assign          reduce using rule 63 (arr_ref -> Identifier arr_idx_list .)
    Mul             reduce using rule 63 (arr_ref -> Identifier arr_idx_list .)
    Div             reduce using rule 63 (arr_ref -> Identifier arr_idx_list .)
    Mod             reduce using rule 63 (arr_ref -> Identifier arr_idx_list .)
    Plus            reduce using rule 63 (arr_ref -> Identifier arr_idx_list .)
    Minus           reduce using rule 63 (arr_ref -> Identifier arr_idx_list .)
    Less            reduce using rule 63 (arr_ref -> Identifier arr_idx_list .)
    Greater         reduce using rule 63 (arr_ref -> Identifier arr_idx_list .)
    LessEqual       reduce using rule 63 (arr_ref -> Identifier arr_idx_list .)
    GreaterEqual    reduce using rule 63 (arr_ref -> Identifier arr_idx_list .)
    NotEqual        reduce using rule 63 (arr_ref -> Identifier arr_idx_list .)
    Equal           reduce using rule 63 (arr_ref -> Identifier arr_idx_list .)
    BitAnd          reduce using rule 63 (arr_ref -> Identifier arr_idx_list .)
    Xor             reduce using rule 63 (arr_ref -> Identifier arr_idx_list .)
    BitOr           reduce using rule 63 (arr_ref -> Identifier arr_idx_list .)
    And             reduce using rule 63 (arr_ref -> Identifier arr_idx_list .)
    Question        reduce using rule 63 (arr_ref -> Identifier arr_idx_list .)
    Or              reduce using rule 63 (arr_ref -> Identifier arr_idx_list .)
    Semi            reduce using rule 63 (arr_ref -> Identifier arr_idx_list .)
    RParen          reduce using rule 63 (arr_ref -> Identifier arr_idx_list .)
    Comma           reduce using rule 63 (arr_ref -> Identifier arr_idx_list .)
    RBracket        reduce using rule 63 (arr_ref -> Identifier arr_idx_list .)
    Colon           reduce using rule 63 (arr_ref -> Identifier arr_idx_list .)


state 45

    (37) postfix -> Identifier LParen . call_para RParen
    (38) call_para -> . expression
    (39) call_para -> . empty
    (40) call_para -> . call_para Comma call_para
    (44) expression -> . assignment
    (4) empty -> .
    (45) assignment -> . conditional
    (64) assignment -> . Identifier Assign expression
    (65) assignment -> . arr_ref Assign expression
    (46) conditional -> . logical_or
    (82) conditional -> . logical_or Question expression Colon conditional
    (63) arr_ref -> . Identifier arr_idx_list
    (47) logical_or -> . logical_and
    (66) logical_or -> . logical_or Or logical_and
    (48) logical_and -> . bit_or
    (67) logical_and -> . logical_and And bit_or
    (49) bit_or -> . xor
    (68) bit_or -> . bit_or BitOr xor
    (50) xor -> . bit_and
    (69) xor -> . xor Xor bit_and
    (51) bit_and -> . equality
    (70) bit_and -> . bit_and BitAnd equality
    (52) equality -> . relational
    (71) equality -> . equality NotEqual relational
    (72) equality -> . equality Equal relational
    (53) relational -> . additive
    (73) relational -> . relational Less additive
    (74) relational -> . relational Greater additive
    (75) relational -> . relational LessEqual additive
    (76) relational -> . relational GreaterEqual additive
    (54) additive -> . multiplicative
    (77) additive -> . additive Plus multiplicative
    (78) additive -> . additive Minus multiplicative
    (55) multiplicative -> . unary
    (79) multiplicative -> . multiplicative Mul unary
    (80) multiplicative -> . multiplicative Div unary
    (81) multiplicative -> . multiplicative Mod unary
    (56) unary -> . postfix
    (58) unary -> . Minus unary
    (59) unary -> . BitNot unary
    (60) unary -> . Not unary
    (37) postfix -> . Identifier LParen call_para RParen
    (57) postfix -> . primary
    (83) primary -> . Integer
    (84) primary -> . Identifier
    (85) primary -> . LParen expression RParen
    (86) primary -> . arr_ref

    RParen          reduce using rule 4 (empty -> .)
    Comma           reduce using rule 4 (empty -> .)
    Identifier      shift and go to state 17
    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Integer         shift and go to state 38
    LParen          shift and go to state 36

    call_para                      shift and go to state 75
    expression                     shift and go to state 76
    empty                          shift and go to state 77
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    arr_ref                        shift and go to state 21
    logical_or                     shift and go to state 22
    logical_and                    shift and go to state 23
    bit_or                         shift and go to state 24
    xor                            shift and go to state 25
    bit_and                        shift and go to state 26
    equality                       shift and go to state 27
    relational                     shift and go to state 28
    additive                       shift and go to state 29
    multiplicative                 shift and go to state 30
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 37

state 46

    (61) arr_idx_list -> LBracket . expression RBracket arr_idx_list
    (62) arr_idx_list -> LBracket . expression RBracket
    (44) expression -> . assignment
    (45) assignment -> . conditional
    (64) assignment -> . Identifier Assign expression
    (65) assignment -> . arr_ref Assign expression
    (46) conditional -> . logical_or
    (82) conditional -> . logical_or Question expression Colon conditional
    (63) arr_ref -> . Identifier arr_idx_list
    (47) logical_or -> . logical_and
    (66) logical_or -> . logical_or Or logical_and
    (48) logical_and -> . bit_or
    (67) logical_and -> . logical_and And bit_or
    (49) bit_or -> . xor
    (68) bit_or -> . bit_or BitOr xor
    (50) xor -> . bit_and
    (69) xor -> . xor Xor bit_and
    (51) bit_and -> . equality
    (70) bit_and -> . bit_and BitAnd equality
    (52) equality -> . relational
    (71) equality -> . equality NotEqual relational
    (72) equality -> . equality Equal relational
    (53) relational -> . additive
    (73) relational -> . relational Less additive
    (74) relational -> . relational Greater additive
    (75) relational -> . relational LessEqual additive
    (76) relational -> . relational GreaterEqual additive
    (54) additive -> . multiplicative
    (77) additive -> . additive Plus multiplicative
    (78) additive -> . additive Minus multiplicative
    (55) multiplicative -> . unary
    (79) multiplicative -> . multiplicative Mul unary
    (80) multiplicative -> . multiplicative Div unary
    (81) multiplicative -> . multiplicative Mod unary
    (56) unary -> . postfix
    (58) unary -> . Minus unary
    (59) unary -> . BitNot unary
    (60) unary -> . Not unary
    (37) postfix -> . Identifier LParen call_para RParen
    (57) postfix -> . primary
    (83) primary -> . Integer
    (84) primary -> . Identifier
    (85) primary -> . LParen expression RParen
    (86) primary -> . arr_ref

    Identifier      shift and go to state 17
    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Integer         shift and go to state 38
    LParen          shift and go to state 36

    expression                     shift and go to state 78
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    arr_ref                        shift and go to state 21
    logical_or                     shift and go to state 22
    logical_and                    shift and go to state 23
    bit_or                         shift and go to state 24
    xor                            shift and go to state 25
    bit_and                        shift and go to state 26
    equality                       shift and go to state 27
    relational                     shift and go to state 28
    additive                       shift and go to state 29
    multiplicative                 shift and go to state 30
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 37

state 47

    (65) assignment -> arr_ref Assign . expression
    (44) expression -> . assignment
    (45) assignment -> . conditional
    (64) assignment -> . Identifier Assign expression
    (65) assignment -> . arr_ref Assign expression
    (46) conditional -> . logical_or
    (82) conditional -> . logical_or Question expression Colon conditional
    (63) arr_ref -> . Identifier arr_idx_list
    (47) logical_or -> . logical_and
    (66) logical_or -> . logical_or Or logical_and
    (48) logical_and -> . bit_or
    (67) logical_and -> . logical_and And bit_or
    (49) bit_or -> . xor
    (68) bit_or -> . bit_or BitOr xor
    (50) xor -> . bit_and
    (69) xor -> . xor Xor bit_and
    (51) bit_and -> . equality
    (70) bit_and -> . bit_and BitAnd equality
    (52) equality -> . relational
    (71) equality -> . equality NotEqual relational
    (72) equality -> . equality Equal relational
    (53) relational -> . additive
    (73) relational -> . relational Less additive
    (74) relational -> . relational Greater additive
    (75) relational -> . relational LessEqual additive
    (76) relational -> . relational GreaterEqual additive
    (54) additive -> . multiplicative
    (77) additive -> . additive Plus multiplicative
    (78) additive -> . additive Minus multiplicative
    (55) multiplicative -> . unary
    (79) multiplicative -> . multiplicative Mul unary
    (80) multiplicative -> . multiplicative Div unary
    (81) multiplicative -> . multiplicative Mod unary
    (56) unary -> . postfix
    (58) unary -> . Minus unary
    (59) unary -> . BitNot unary
    (60) unary -> . Not unary
    (37) postfix -> . Identifier LParen call_para RParen
    (57) postfix -> . primary
    (83) primary -> . Integer
    (84) primary -> . Identifier
    (85) primary -> . LParen expression RParen
    (86) primary -> . arr_ref

    Identifier      shift and go to state 17
    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Integer         shift and go to state 38
    LParen          shift and go to state 36

    arr_ref                        shift and go to state 21
    expression                     shift and go to state 79
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    logical_or                     shift and go to state 22
    logical_and                    shift and go to state 23
    bit_or                         shift and go to state 24
    xor                            shift and go to state 25
    bit_and                        shift and go to state 26
    equality                       shift and go to state 27
    relational                     shift and go to state 28
    additive                       shift and go to state 29
    multiplicative                 shift and go to state 30
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 37

state 48

    (82) conditional -> logical_or Question . expression Colon conditional
    (44) expression -> . assignment
    (45) assignment -> . conditional
    (64) assignment -> . Identifier Assign expression
    (65) assignment -> . arr_ref Assign expression
    (46) conditional -> . logical_or
    (82) conditional -> . logical_or Question expression Colon conditional
    (63) arr_ref -> . Identifier arr_idx_list
    (47) logical_or -> . logical_and
    (66) logical_or -> . logical_or Or logical_and
    (48) logical_and -> . bit_or
    (67) logical_and -> . logical_and And bit_or
    (49) bit_or -> . xor
    (68) bit_or -> . bit_or BitOr xor
    (50) xor -> . bit_and
    (69) xor -> . xor Xor bit_and
    (51) bit_and -> . equality
    (70) bit_and -> . bit_and BitAnd equality
    (52) equality -> . relational
    (71) equality -> . equality NotEqual relational
    (72) equality -> . equality Equal relational
    (53) relational -> . additive
    (73) relational -> . relational Less additive
    (74) relational -> . relational Greater additive
    (75) relational -> . relational LessEqual additive
    (76) relational -> . relational GreaterEqual additive
    (54) additive -> . multiplicative
    (77) additive -> . additive Plus multiplicative
    (78) additive -> . additive Minus multiplicative
    (55) multiplicative -> . unary
    (79) multiplicative -> . multiplicative Mul unary
    (80) multiplicative -> . multiplicative Div unary
    (81) multiplicative -> . multiplicative Mod unary
    (56) unary -> . postfix
    (58) unary -> . Minus unary
    (59) unary -> . BitNot unary
    (60) unary -> . Not unary
    (37) postfix -> . Identifier LParen call_para RParen
    (57) postfix -> . primary
    (83) primary -> . Integer
    (84) primary -> . Identifier
    (85) primary -> . LParen expression RParen
    (86) primary -> . arr_ref

    Identifier      shift and go to state 17
    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Integer         shift and go to state 38
    LParen          shift and go to state 36

    logical_or                     shift and go to state 22
    expression                     shift and go to state 80
    conditional                    shift and go to state 20
    assignment                     shift and go to state 19
    arr_ref                        shift and go to state 21
    logical_and                    shift and go to state 23
    bit_or                         shift and go to state 24
    xor                            shift and go to state 25
    bit_and                        shift and go to state 26
    equality                       shift and go to state 27
    relational                     shift and go to state 28
    additive                       shift and go to state 29
    multiplicative                 shift and go to state 30
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 37

state 49

    (66) logical_or -> logical_or Or . logical_and
    (48) logical_and -> . bit_or
    (67) logical_and -> . logical_and And bit_or
    (49) bit_or -> . xor
    (68) bit_or -> . bit_or BitOr xor
    (50) xor -> . bit_and
    (69) xor -> . xor Xor bit_and
    (51) bit_and -> . equality
    (70) bit_and -> . bit_and BitAnd equality
    (52) equality -> . relational
    (71) equality -> . equality NotEqual relational
    (72) equality -> . equality Equal relational
    (53) relational -> . additive
    (73) relational -> . relational Less additive
    (74) relational -> . relational Greater additive
    (75) relational -> . relational LessEqual additive
    (76) relational -> . relational GreaterEqual additive
    (54) additive -> . multiplicative
    (77) additive -> . additive Plus multiplicative
    (78) additive -> . additive Minus multiplicative
    (55) multiplicative -> . unary
    (79) multiplicative -> . multiplicative Mul unary
    (80) multiplicative -> . multiplicative Div unary
    (81) multiplicative -> . multiplicative Mod unary
    (56) unary -> . postfix
    (58) unary -> . Minus unary
    (59) unary -> . BitNot unary
    (60) unary -> . Not unary
    (37) postfix -> . Identifier LParen call_para RParen
    (57) postfix -> . primary
    (83) primary -> . Integer
    (84) primary -> . Identifier
    (85) primary -> . LParen expression RParen
    (86) primary -> . arr_ref
    (63) arr_ref -> . Identifier arr_idx_list

    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Identifier      shift and go to state 66
    Integer         shift and go to state 38
    LParen          shift and go to state 36

    logical_and                    shift and go to state 81
    bit_or                         shift and go to state 24
    xor                            shift and go to state 25
    bit_and                        shift and go to state 26
    equality                       shift and go to state 27
    relational                     shift and go to state 28
    additive                       shift and go to state 29
    multiplicative                 shift and go to state 30
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 37
    arr_ref                        shift and go to state 67

state 50

    (67) logical_and -> logical_and And . bit_or
    (49) bit_or -> . xor
    (68) bit_or -> . bit_or BitOr xor
    (50) xor -> . bit_and
    (69) xor -> . xor Xor bit_and
    (51) bit_and -> . equality
    (70) bit_and -> . bit_and BitAnd equality
    (52) equality -> . relational
    (71) equality -> . equality NotEqual relational
    (72) equality -> . equality Equal relational
    (53) relational -> . additive
    (73) relational -> . relational Less additive
    (74) relational -> . relational Greater additive
    (75) relational -> . relational LessEqual additive
    (76) relational -> . relational GreaterEqual additive
    (54) additive -> . multiplicative
    (77) additive -> . additive Plus multiplicative
    (78) additive -> . additive Minus multiplicative
    (55) multiplicative -> . unary
    (79) multiplicative -> . multiplicative Mul unary
    (80) multiplicative -> . multiplicative Div unary
    (81) multiplicative -> . multiplicative Mod unary
    (56) unary -> . postfix
    (58) unary -> . Minus unary
    (59) unary -> . BitNot unary
    (60) unary -> . Not unary
    (37) postfix -> . Identifier LParen call_para RParen
    (57) postfix -> . primary
    (83) primary -> . Integer
    (84) primary -> . Identifier
    (85) primary -> . LParen expression RParen
    (86) primary -> . arr_ref
    (63) arr_ref -> . Identifier arr_idx_list

    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Identifier      shift and go to state 66
    Integer         shift and go to state 38
    LParen          shift and go to state 36

    bit_or                         shift and go to state 82
    xor                            shift and go to state 25
    bit_and                        shift and go to state 26
    equality                       shift and go to state 27
    relational                     shift and go to state 28
    additive                       shift and go to state 29
    multiplicative                 shift and go to state 30
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 37
    arr_ref                        shift and go to state 67

state 51

    (68) bit_or -> bit_or BitOr . xor
    (50) xor -> . bit_and
    (69) xor -> . xor Xor bit_and
    (51) bit_and -> . equality
    (70) bit_and -> . bit_and BitAnd equality
    (52) equality -> . relational
    (71) equality -> . equality NotEqual relational
    (72) equality -> . equality Equal relational
    (53) relational -> . additive
    (73) relational -> . relational Less additive
    (74) relational -> . relational Greater additive
    (75) relational -> . relational LessEqual additive
    (76) relational -> . relational GreaterEqual additive
    (54) additive -> . multiplicative
    (77) additive -> . additive Plus multiplicative
    (78) additive -> . additive Minus multiplicative
    (55) multiplicative -> . unary
    (79) multiplicative -> . multiplicative Mul unary
    (80) multiplicative -> . multiplicative Div unary
    (81) multiplicative -> . multiplicative Mod unary
    (56) unary -> . postfix
    (58) unary -> . Minus unary
    (59) unary -> . BitNot unary
    (60) unary -> . Not unary
    (37) postfix -> . Identifier LParen call_para RParen
    (57) postfix -> . primary
    (83) primary -> . Integer
    (84) primary -> . Identifier
    (85) primary -> . LParen expression RParen
    (86) primary -> . arr_ref
    (63) arr_ref -> . Identifier arr_idx_list

    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Identifier      shift and go to state 66
    Integer         shift and go to state 38
    LParen          shift and go to state 36

    xor                            shift and go to state 83
    bit_and                        shift and go to state 26
    equality                       shift and go to state 27
    relational                     shift and go to state 28
    additive                       shift and go to state 29
    multiplicative                 shift and go to state 30
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 37
    arr_ref                        shift and go to state 67

state 52

    (69) xor -> xor Xor . bit_and
    (51) bit_and -> . equality
    (70) bit_and -> . bit_and BitAnd equality
    (52) equality -> . relational
    (71) equality -> . equality NotEqual relational
    (72) equality -> . equality Equal relational
    (53) relational -> . additive
    (73) relational -> . relational Less additive
    (74) relational -> . relational Greater additive
    (75) relational -> . relational LessEqual additive
    (76) relational -> . relational GreaterEqual additive
    (54) additive -> . multiplicative
    (77) additive -> . additive Plus multiplicative
    (78) additive -> . additive Minus multiplicative
    (55) multiplicative -> . unary
    (79) multiplicative -> . multiplicative Mul unary
    (80) multiplicative -> . multiplicative Div unary
    (81) multiplicative -> . multiplicative Mod unary
    (56) unary -> . postfix
    (58) unary -> . Minus unary
    (59) unary -> . BitNot unary
    (60) unary -> . Not unary
    (37) postfix -> . Identifier LParen call_para RParen
    (57) postfix -> . primary
    (83) primary -> . Integer
    (84) primary -> . Identifier
    (85) primary -> . LParen expression RParen
    (86) primary -> . arr_ref
    (63) arr_ref -> . Identifier arr_idx_list

    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Identifier      shift and go to state 66
    Integer         shift and go to state 38
    LParen          shift and go to state 36

    bit_and                        shift and go to state 84
    equality                       shift and go to state 27
    relational                     shift and go to state 28
    additive                       shift and go to state 29
    multiplicative                 shift and go to state 30
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 37
    arr_ref                        shift and go to state 67

state 53

    (70) bit_and -> bit_and BitAnd . equality
    (52) equality -> . relational
    (71) equality -> . equality NotEqual relational
    (72) equality -> . equality Equal relational
    (53) relational -> . additive
    (73) relational -> . relational Less additive
    (74) relational -> . relational Greater additive
    (75) relational -> . relational LessEqual additive
    (76) relational -> . relational GreaterEqual additive
    (54) additive -> . multiplicative
    (77) additive -> . additive Plus multiplicative
    (78) additive -> . additive Minus multiplicative
    (55) multiplicative -> . unary
    (79) multiplicative -> . multiplicative Mul unary
    (80) multiplicative -> . multiplicative Div unary
    (81) multiplicative -> . multiplicative Mod unary
    (56) unary -> . postfix
    (58) unary -> . Minus unary
    (59) unary -> . BitNot unary
    (60) unary -> . Not unary
    (37) postfix -> . Identifier LParen call_para RParen
    (57) postfix -> . primary
    (83) primary -> . Integer
    (84) primary -> . Identifier
    (85) primary -> . LParen expression RParen
    (86) primary -> . arr_ref
    (63) arr_ref -> . Identifier arr_idx_list

    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Identifier      shift and go to state 66
    Integer         shift and go to state 38
    LParen          shift and go to state 36

    equality                       shift and go to state 85
    relational                     shift and go to state 28
    additive                       shift and go to state 29
    multiplicative                 shift and go to state 30
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 37
    arr_ref                        shift and go to state 67

state 54

    (71) equality -> equality NotEqual . relational
    (53) relational -> . additive
    (73) relational -> . relational Less additive
    (74) relational -> . relational Greater additive
    (75) relational -> . relational LessEqual additive
    (76) relational -> . relational GreaterEqual additive
    (54) additive -> . multiplicative
    (77) additive -> . additive Plus multiplicative
    (78) additive -> . additive Minus multiplicative
    (55) multiplicative -> . unary
    (79) multiplicative -> . multiplicative Mul unary
    (80) multiplicative -> . multiplicative Div unary
    (81) multiplicative -> . multiplicative Mod unary
    (56) unary -> . postfix
    (58) unary -> . Minus unary
    (59) unary -> . BitNot unary
    (60) unary -> . Not unary
    (37) postfix -> . Identifier LParen call_para RParen
    (57) postfix -> . primary
    (83) primary -> . Integer
    (84) primary -> . Identifier
    (85) primary -> . LParen expression RParen
    (86) primary -> . arr_ref
    (63) arr_ref -> . Identifier arr_idx_list

    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Identifier      shift and go to state 66
    Integer         shift and go to state 38
    LParen          shift and go to state 36

    relational                     shift and go to state 86
    additive                       shift and go to state 29
    multiplicative                 shift and go to state 30
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 37
    arr_ref                        shift and go to state 67

state 55

    (72) equality -> equality Equal . relational
    (53) relational -> . additive
    (73) relational -> . relational Less additive
    (74) relational -> . relational Greater additive
    (75) relational -> . relational LessEqual additive
    (76) relational -> . relational GreaterEqual additive
    (54) additive -> . multiplicative
    (77) additive -> . additive Plus multiplicative
    (78) additive -> . additive Minus multiplicative
    (55) multiplicative -> . unary
    (79) multiplicative -> . multiplicative Mul unary
    (80) multiplicative -> . multiplicative Div unary
    (81) multiplicative -> . multiplicative Mod unary
    (56) unary -> . postfix
    (58) unary -> . Minus unary
    (59) unary -> . BitNot unary
    (60) unary -> . Not unary
    (37) postfix -> . Identifier LParen call_para RParen
    (57) postfix -> . primary
    (83) primary -> . Integer
    (84) primary -> . Identifier
    (85) primary -> . LParen expression RParen
    (86) primary -> . arr_ref
    (63) arr_ref -> . Identifier arr_idx_list

    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Identifier      shift and go to state 66
    Integer         shift and go to state 38
    LParen          shift and go to state 36

    relational                     shift and go to state 87
    additive                       shift and go to state 29
    multiplicative                 shift and go to state 30
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 37
    arr_ref                        shift and go to state 67

state 56

    (73) relational -> relational Less . additive
    (54) additive -> . multiplicative
    (77) additive -> . additive Plus multiplicative
    (78) additive -> . additive Minus multiplicative
    (55) multiplicative -> . unary
    (79) multiplicative -> . multiplicative Mul unary
    (80) multiplicative -> . multiplicative Div unary
    (81) multiplicative -> . multiplicative Mod unary
    (56) unary -> . postfix
    (58) unary -> . Minus unary
    (59) unary -> . BitNot unary
    (60) unary -> . Not unary
    (37) postfix -> . Identifier LParen call_para RParen
    (57) postfix -> . primary
    (83) primary -> . Integer
    (84) primary -> . Identifier
    (85) primary -> . LParen expression RParen
    (86) primary -> . arr_ref
    (63) arr_ref -> . Identifier arr_idx_list

    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Identifier      shift and go to state 66
    Integer         shift and go to state 38
    LParen          shift and go to state 36

    additive                       shift and go to state 88
    multiplicative                 shift and go to state 30
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 37
    arr_ref                        shift and go to state 67

state 57

    (74) relational -> relational Greater . additive
    (54) additive -> . multiplicative
    (77) additive -> . additive Plus multiplicative
    (78) additive -> . additive Minus multiplicative
    (55) multiplicative -> . unary
    (79) multiplicative -> . multiplicative Mul unary
    (80) multiplicative -> . multiplicative Div unary
    (81) multiplicative -> . multiplicative Mod unary
    (56) unary -> . postfix
    (58) unary -> . Minus unary
    (59) unary -> . BitNot unary
    (60) unary -> . Not unary
    (37) postfix -> . Identifier LParen call_para RParen
    (57) postfix -> . primary
    (83) primary -> . Integer
    (84) primary -> . Identifier
    (85) primary -> . LParen expression RParen
    (86) primary -> . arr_ref
    (63) arr_ref -> . Identifier arr_idx_list

    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Identifier      shift and go to state 66
    Integer         shift and go to state 38
    LParen          shift and go to state 36

    additive                       shift and go to state 89
    multiplicative                 shift and go to state 30
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 37
    arr_ref                        shift and go to state 67

state 58

    (75) relational -> relational LessEqual . additive
    (54) additive -> . multiplicative
    (77) additive -> . additive Plus multiplicative
    (78) additive -> . additive Minus multiplicative
    (55) multiplicative -> . unary
    (79) multiplicative -> . multiplicative Mul unary
    (80) multiplicative -> . multiplicative Div unary
    (81) multiplicative -> . multiplicative Mod unary
    (56) unary -> . postfix
    (58) unary -> . Minus unary
    (59) unary -> . BitNot unary
    (60) unary -> . Not unary
    (37) postfix -> . Identifier LParen call_para RParen
    (57) postfix -> . primary
    (83) primary -> . Integer
    (84) primary -> . Identifier
    (85) primary -> . LParen expression RParen
    (86) primary -> . arr_ref
    (63) arr_ref -> . Identifier arr_idx_list

    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Identifier      shift and go to state 66
    Integer         shift and go to state 38
    LParen          shift and go to state 36

    additive                       shift and go to state 90
    multiplicative                 shift and go to state 30
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 37
    arr_ref                        shift and go to state 67

state 59

    (76) relational -> relational GreaterEqual . additive
    (54) additive -> . multiplicative
    (77) additive -> . additive Plus multiplicative
    (78) additive -> . additive Minus multiplicative
    (55) multiplicative -> . unary
    (79) multiplicative -> . multiplicative Mul unary
    (80) multiplicative -> . multiplicative Div unary
    (81) multiplicative -> . multiplicative Mod unary
    (56) unary -> . postfix
    (58) unary -> . Minus unary
    (59) unary -> . BitNot unary
    (60) unary -> . Not unary
    (37) postfix -> . Identifier LParen call_para RParen
    (57) postfix -> . primary
    (83) primary -> . Integer
    (84) primary -> . Identifier
    (85) primary -> . LParen expression RParen
    (86) primary -> . arr_ref
    (63) arr_ref -> . Identifier arr_idx_list

    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Identifier      shift and go to state 66
    Integer         shift and go to state 38
    LParen          shift and go to state 36

    additive                       shift and go to state 91
    multiplicative                 shift and go to state 30
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 37
    arr_ref                        shift and go to state 67

state 60

    (77) additive -> additive Plus . multiplicative
    (55) multiplicative -> . unary
    (79) multiplicative -> . multiplicative Mul unary
    (80) multiplicative -> . multiplicative Div unary
    (81) multiplicative -> . multiplicative Mod unary
    (56) unary -> . postfix
    (58) unary -> . Minus unary
    (59) unary -> . BitNot unary
    (60) unary -> . Not unary
    (37) postfix -> . Identifier LParen call_para RParen
    (57) postfix -> . primary
    (83) primary -> . Integer
    (84) primary -> . Identifier
    (85) primary -> . LParen expression RParen
    (86) primary -> . arr_ref
    (63) arr_ref -> . Identifier arr_idx_list

    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Identifier      shift and go to state 66
    Integer         shift and go to state 38
    LParen          shift and go to state 36

    multiplicative                 shift and go to state 92
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 37
    arr_ref                        shift and go to state 67

state 61

    (78) additive -> additive Minus . multiplicative
    (55) multiplicative -> . unary
    (79) multiplicative -> . multiplicative Mul unary
    (80) multiplicative -> . multiplicative Div unary
    (81) multiplicative -> . multiplicative Mod unary
    (56) unary -> . postfix
    (58) unary -> . Minus unary
    (59) unary -> . BitNot unary
    (60) unary -> . Not unary
    (37) postfix -> . Identifier LParen call_para RParen
    (57) postfix -> . primary
    (83) primary -> . Integer
    (84) primary -> . Identifier
    (85) primary -> . LParen expression RParen
    (86) primary -> . arr_ref
    (63) arr_ref -> . Identifier arr_idx_list

    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Identifier      shift and go to state 66
    Integer         shift and go to state 38
    LParen          shift and go to state 36

    multiplicative                 shift and go to state 93
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 37
    arr_ref                        shift and go to state 67

state 62

    (79) multiplicative -> multiplicative Mul . unary
    (56) unary -> . postfix
    (58) unary -> . Minus unary
    (59) unary -> . BitNot unary
    (60) unary -> . Not unary
    (37) postfix -> . Identifier LParen call_para RParen
    (57) postfix -> . primary
    (83) primary -> . Integer
    (84) primary -> . Identifier
    (85) primary -> . LParen expression RParen
    (86) primary -> . arr_ref
    (63) arr_ref -> . Identifier arr_idx_list

    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Identifier      shift and go to state 66
    Integer         shift and go to state 38
    LParen          shift and go to state 36

    unary                          shift and go to state 94
    postfix                        shift and go to state 33
    primary                        shift and go to state 37
    arr_ref                        shift and go to state 67

state 63

    (80) multiplicative -> multiplicative Div . unary
    (56) unary -> . postfix
    (58) unary -> . Minus unary
    (59) unary -> . BitNot unary
    (60) unary -> . Not unary
    (37) postfix -> . Identifier LParen call_para RParen
    (57) postfix -> . primary
    (83) primary -> . Integer
    (84) primary -> . Identifier
    (85) primary -> . LParen expression RParen
    (86) primary -> . arr_ref
    (63) arr_ref -> . Identifier arr_idx_list

    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Identifier      shift and go to state 66
    Integer         shift and go to state 38
    LParen          shift and go to state 36

    unary                          shift and go to state 95
    postfix                        shift and go to state 33
    primary                        shift and go to state 37
    arr_ref                        shift and go to state 67

state 64

    (81) multiplicative -> multiplicative Mod . unary
    (56) unary -> . postfix
    (58) unary -> . Minus unary
    (59) unary -> . BitNot unary
    (60) unary -> . Not unary
    (37) postfix -> . Identifier LParen call_para RParen
    (57) postfix -> . primary
    (83) primary -> . Integer
    (84) primary -> . Identifier
    (85) primary -> . LParen expression RParen
    (86) primary -> . arr_ref
    (63) arr_ref -> . Identifier arr_idx_list

    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Identifier      shift and go to state 66
    Integer         shift and go to state 38
    LParen          shift and go to state 36

    unary                          shift and go to state 96
    postfix                        shift and go to state 33
    primary                        shift and go to state 37
    arr_ref                        shift and go to state 67

state 65

    (58) unary -> Minus unary .

    Mul             reduce using rule 58 (unary -> Minus unary .)
    Div             reduce using rule 58 (unary -> Minus unary .)
    Mod             reduce using rule 58 (unary -> Minus unary .)
    Plus            reduce using rule 58 (unary -> Minus unary .)
    Minus           reduce using rule 58 (unary -> Minus unary .)
    Less            reduce using rule 58 (unary -> Minus unary .)
    Greater         reduce using rule 58 (unary -> Minus unary .)
    LessEqual       reduce using rule 58 (unary -> Minus unary .)
    GreaterEqual    reduce using rule 58 (unary -> Minus unary .)
    NotEqual        reduce using rule 58 (unary -> Minus unary .)
    Equal           reduce using rule 58 (unary -> Minus unary .)
    BitAnd          reduce using rule 58 (unary -> Minus unary .)
    Xor             reduce using rule 58 (unary -> Minus unary .)
    BitOr           reduce using rule 58 (unary -> Minus unary .)
    And             reduce using rule 58 (unary -> Minus unary .)
    Question        reduce using rule 58 (unary -> Minus unary .)
    Or              reduce using rule 58 (unary -> Minus unary .)
    Semi            reduce using rule 58 (unary -> Minus unary .)
    RParen          reduce using rule 58 (unary -> Minus unary .)
    Comma           reduce using rule 58 (unary -> Minus unary .)
    RBracket        reduce using rule 58 (unary -> Minus unary .)
    Colon           reduce using rule 58 (unary -> Minus unary .)


state 66

    (37) postfix -> Identifier . LParen call_para RParen
    (84) primary -> Identifier .
    (63) arr_ref -> Identifier . arr_idx_list
    (61) arr_idx_list -> . LBracket expression RBracket arr_idx_list
    (62) arr_idx_list -> . LBracket expression RBracket

    LParen          shift and go to state 45
    Mul             reduce using rule 84 (primary -> Identifier .)
    Div             reduce using rule 84 (primary -> Identifier .)
    Mod             reduce using rule 84 (primary -> Identifier .)
    Plus            reduce using rule 84 (primary -> Identifier .)
    Minus           reduce using rule 84 (primary -> Identifier .)
    Less            reduce using rule 84 (primary -> Identifier .)
    Greater         reduce using rule 84 (primary -> Identifier .)
    LessEqual       reduce using rule 84 (primary -> Identifier .)
    GreaterEqual    reduce using rule 84 (primary -> Identifier .)
    NotEqual        reduce using rule 84 (primary -> Identifier .)
    Equal           reduce using rule 84 (primary -> Identifier .)
    BitAnd          reduce using rule 84 (primary -> Identifier .)
    Xor             reduce using rule 84 (primary -> Identifier .)
    BitOr           reduce using rule 84 (primary -> Identifier .)
    And             reduce using rule 84 (primary -> Identifier .)
    Question        reduce using rule 84 (primary -> Identifier .)
    Or              reduce using rule 84 (primary -> Identifier .)
    Semi            reduce using rule 84 (primary -> Identifier .)
    RParen          reduce using rule 84 (primary -> Identifier .)
    Comma           reduce using rule 84 (primary -> Identifier .)
    RBracket        reduce using rule 84 (primary -> Identifier .)
    Colon           reduce using rule 84 (primary -> Identifier .)
    LBracket        shift and go to state 46

    arr_idx_list                   shift and go to state 44

state 67

    (86) primary -> arr_ref .

    Mul             reduce using rule 86 (primary -> arr_ref .)
    Div             reduce using rule 86 (primary -> arr_ref .)
    Mod             reduce using rule 86 (primary -> arr_ref .)
    Plus            reduce using rule 86 (primary -> arr_ref .)
    Minus           reduce using rule 86 (primary -> arr_ref .)
    Less            reduce using rule 86 (primary -> arr_ref .)
    Greater         reduce using rule 86 (primary -> arr_ref .)
    LessEqual       reduce using rule 86 (primary -> arr_ref .)
    GreaterEqual    reduce using rule 86 (primary -> arr_ref .)
    NotEqual        reduce using rule 86 (primary -> arr_ref .)
    Equal           reduce using rule 86 (primary -> arr_ref .)
    BitAnd          reduce using rule 86 (primary -> arr_ref .)
    Xor             reduce using rule 86 (primary -> arr_ref .)
    BitOr           reduce using rule 86 (primary -> arr_ref .)
    And             reduce using rule 86 (primary -> arr_ref .)
    Question        reduce using rule 86 (primary -> arr_ref .)
    Or              reduce using rule 86 (primary -> arr_ref .)
    Semi            reduce using rule 86 (primary -> arr_ref .)
    RParen          reduce using rule 86 (primary -> arr_ref .)
    Comma           reduce using rule 86 (primary -> arr_ref .)
    RBracket        reduce using rule 86 (primary -> arr_ref .)
    Colon           reduce using rule 86 (primary -> arr_ref .)


state 68

    (59) unary -> BitNot unary .

    Mul             reduce using rule 59 (unary -> BitNot unary .)
    Div             reduce using rule 59 (unary -> BitNot unary .)
    Mod             reduce using rule 59 (unary -> BitNot unary .)
    Plus            reduce using rule 59 (unary -> BitNot unary .)
    Minus           reduce using rule 59 (unary -> BitNot unary .)
    Less            reduce using rule 59 (unary -> BitNot unary .)
    Greater         reduce using rule 59 (unary -> BitNot unary .)
    LessEqual       reduce using rule 59 (unary -> BitNot unary .)
    GreaterEqual    reduce using rule 59 (unary -> BitNot unary .)
    NotEqual        reduce using rule 59 (unary -> BitNot unary .)
    Equal           reduce using rule 59 (unary -> BitNot unary .)
    BitAnd          reduce using rule 59 (unary -> BitNot unary .)
    Xor             reduce using rule 59 (unary -> BitNot unary .)
    BitOr           reduce using rule 59 (unary -> BitNot unary .)
    And             reduce using rule 59 (unary -> BitNot unary .)
    Question        reduce using rule 59 (unary -> BitNot unary .)
    Or              reduce using rule 59 (unary -> BitNot unary .)
    Semi            reduce using rule 59 (unary -> BitNot unary .)
    RParen          reduce using rule 59 (unary -> BitNot unary .)
    Comma           reduce using rule 59 (unary -> BitNot unary .)
    RBracket        reduce using rule 59 (unary -> BitNot unary .)
    Colon           reduce using rule 59 (unary -> BitNot unary .)


state 69

    (60) unary -> Not unary .

    Mul             reduce using rule 60 (unary -> Not unary .)
    Div             reduce using rule 60 (unary -> Not unary .)
    Mod             reduce using rule 60 (unary -> Not unary .)
    Plus            reduce using rule 60 (unary -> Not unary .)
    Minus           reduce using rule 60 (unary -> Not unary .)
    Less            reduce using rule 60 (unary -> Not unary .)
    Greater         reduce using rule 60 (unary -> Not unary .)
    LessEqual       reduce using rule 60 (unary -> Not unary .)
    GreaterEqual    reduce using rule 60 (unary -> Not unary .)
    NotEqual        reduce using rule 60 (unary -> Not unary .)
    Equal           reduce using rule 60 (unary -> Not unary .)
    BitAnd          reduce using rule 60 (unary -> Not unary .)
    Xor             reduce using rule 60 (unary -> Not unary .)
    BitOr           reduce using rule 60 (unary -> Not unary .)
    And             reduce using rule 60 (unary -> Not unary .)
    Question        reduce using rule 60 (unary -> Not unary .)
    Or              reduce using rule 60 (unary -> Not unary .)
    Semi            reduce using rule 60 (unary -> Not unary .)
    RParen          reduce using rule 60 (unary -> Not unary .)
    Comma           reduce using rule 60 (unary -> Not unary .)
    RBracket        reduce using rule 60 (unary -> Not unary .)
    Colon           reduce using rule 60 (unary -> Not unary .)


state 70

    (85) primary -> LParen expression . RParen

    RParen          shift and go to state 97


state 71

    (34) arr_dim_list -> LBracket Integer RBracket . arr_dim_list
    (35) arr_dim_list -> LBracket Integer RBracket .
    (34) arr_dim_list -> . LBracket Integer RBracket arr_dim_list
    (35) arr_dim_list -> . LBracket Integer RBracket

    Semi            reduce using rule 35 (arr_dim_list -> LBracket Integer RBracket .)
    LBracket        shift and go to state 13

    arr_dim_list                   shift and go to state 98

state 72

    (7) function -> type Identifier LParen Parameter RParen LBrace . block RBrace
    (8) block -> . block block_item
    (9) block -> . empty
    (4) empty -> .

    RBrace          reduce using rule 4 (empty -> .)
    If              reduce using rule 4 (empty -> .)
    While           reduce using rule 4 (empty -> .)
    For             reduce using rule 4 (empty -> .)
    Do              reduce using rule 4 (empty -> .)
    Return          reduce using rule 4 (empty -> .)
    LBrace          reduce using rule 4 (empty -> .)
    Break           reduce using rule 4 (empty -> .)
    Continue        reduce using rule 4 (empty -> .)
    Int             reduce using rule 4 (empty -> .)
    Identifier      reduce using rule 4 (empty -> .)
    Minus           reduce using rule 4 (empty -> .)
    BitNot          reduce using rule 4 (empty -> .)
    Not             reduce using rule 4 (empty -> .)
    Integer         reduce using rule 4 (empty -> .)
    LParen          reduce using rule 4 (empty -> .)
    Semi            reduce using rule 4 (empty -> .)

    block                          shift and go to state 99
    empty                          shift and go to state 100

state 73

    (42) Parameter -> Parameter Comma Parameter .
    (42) Parameter -> Parameter . Comma Parameter

  ! shift/reduce conflict for Comma resolved as shift
    RParen          reduce using rule 42 (Parameter -> Parameter Comma Parameter .)
    Comma           shift and go to state 42

  ! Comma           [ reduce using rule 42 (Parameter -> Parameter Comma Parameter .) ]


state 74

    (64) assignment -> Identifier Assign expression .

    Semi            reduce using rule 64 (assignment -> Identifier Assign expression .)
    RParen          reduce using rule 64 (assignment -> Identifier Assign expression .)
    Comma           reduce using rule 64 (assignment -> Identifier Assign expression .)
    RBracket        reduce using rule 64 (assignment -> Identifier Assign expression .)
    Colon           reduce using rule 64 (assignment -> Identifier Assign expression .)


state 75

    (37) postfix -> Identifier LParen call_para . RParen
    (40) call_para -> call_para . Comma call_para

    RParen          shift and go to state 101
    Comma           shift and go to state 102


state 76

    (38) call_para -> expression .

    RParen          reduce using rule 38 (call_para -> expression .)
    Comma           reduce using rule 38 (call_para -> expression .)


state 77

    (39) call_para -> empty .

    RParen          reduce using rule 39 (call_para -> empty .)
    Comma           reduce using rule 39 (call_para -> empty .)


state 78

    (61) arr_idx_list -> LBracket expression . RBracket arr_idx_list
    (62) arr_idx_list -> LBracket expression . RBracket

    RBracket        shift and go to state 103


state 79

    (65) assignment -> arr_ref Assign expression .

    Semi            reduce using rule 65 (assignment -> arr_ref Assign expression .)
    RParen          reduce using rule 65 (assignment -> arr_ref Assign expression .)
    Comma           reduce using rule 65 (assignment -> arr_ref Assign expression .)
    RBracket        reduce using rule 65 (assignment -> arr_ref Assign expression .)
    Colon           reduce using rule 65 (assignment -> arr_ref Assign expression .)


state 80

    (82) conditional -> logical_or Question expression . Colon conditional

    Colon           shift and go to state 104


state 81

    (66) logical_or -> logical_or Or logical_and .
    (67) logical_and -> logical_and . And bit_or

    Question        reduce using rule 66 (logical_or -> logical_or Or logical_and .)
    Or              reduce using rule 66 (logical_or -> logical_or Or logical_and .)
    Semi            reduce using rule 66 (logical_or -> logical_or Or logical_and .)
    RParen          reduce using rule 66 (logical_or -> logical_or Or logical_and .)
    Comma           reduce using rule 66 (logical_or -> logical_or Or logical_and .)
    RBracket        reduce using rule 66 (logical_or -> logical_or Or logical_and .)
    Colon           reduce using rule 66 (logical_or -> logical_or Or logical_and .)
    And             shift and go to state 50


state 82

    (67) logical_and -> logical_and And bit_or .
    (68) bit_or -> bit_or . BitOr xor

    And             reduce using rule 67 (logical_and -> logical_and And bit_or .)
    Question        reduce using rule 67 (logical_and -> logical_and And bit_or .)
    Or              reduce using rule 67 (logical_and -> logical_and And bit_or .)
    Semi            reduce using rule 67 (logical_and -> logical_and And bit_or .)
    RParen          reduce using rule 67 (logical_and -> logical_and And bit_or .)
    Comma           reduce using rule 67 (logical_and -> logical_and And bit_or .)
    RBracket        reduce using rule 67 (logical_and -> logical_and And bit_or .)
    Colon           reduce using rule 67 (logical_and -> logical_and And bit_or .)
    BitOr           shift and go to state 51


state 83

    (68) bit_or -> bit_or BitOr xor .
    (69) xor -> xor . Xor bit_and

    BitOr           reduce using rule 68 (bit_or -> bit_or BitOr xor .)
    And             reduce using rule 68 (bit_or -> bit_or BitOr xor .)
    Question        reduce using rule 68 (bit_or -> bit_or BitOr xor .)
    Or              reduce using rule 68 (bit_or -> bit_or BitOr xor .)
    Semi            reduce using rule 68 (bit_or -> bit_or BitOr xor .)
    RParen          reduce using rule 68 (bit_or -> bit_or BitOr xor .)
    Comma           reduce using rule 68 (bit_or -> bit_or BitOr xor .)
    RBracket        reduce using rule 68 (bit_or -> bit_or BitOr xor .)
    Colon           reduce using rule 68 (bit_or -> bit_or BitOr xor .)
    Xor             shift and go to state 52


state 84

    (69) xor -> xor Xor bit_and .
    (70) bit_and -> bit_and . BitAnd equality

    Xor             reduce using rule 69 (xor -> xor Xor bit_and .)
    BitOr           reduce using rule 69 (xor -> xor Xor bit_and .)
    And             reduce using rule 69 (xor -> xor Xor bit_and .)
    Question        reduce using rule 69 (xor -> xor Xor bit_and .)
    Or              reduce using rule 69 (xor -> xor Xor bit_and .)
    Semi            reduce using rule 69 (xor -> xor Xor bit_and .)
    RParen          reduce using rule 69 (xor -> xor Xor bit_and .)
    Comma           reduce using rule 69 (xor -> xor Xor bit_and .)
    RBracket        reduce using rule 69 (xor -> xor Xor bit_and .)
    Colon           reduce using rule 69 (xor -> xor Xor bit_and .)
    BitAnd          shift and go to state 53


state 85

    (70) bit_and -> bit_and BitAnd equality .
    (71) equality -> equality . NotEqual relational
    (72) equality -> equality . Equal relational

    BitAnd          reduce using rule 70 (bit_and -> bit_and BitAnd equality .)
    Xor             reduce using rule 70 (bit_and -> bit_and BitAnd equality .)
    BitOr           reduce using rule 70 (bit_and -> bit_and BitAnd equality .)
    And             reduce using rule 70 (bit_and -> bit_and BitAnd equality .)
    Question        reduce using rule 70 (bit_and -> bit_and BitAnd equality .)
    Or              reduce using rule 70 (bit_and -> bit_and BitAnd equality .)
    Semi            reduce using rule 70 (bit_and -> bit_and BitAnd equality .)
    RParen          reduce using rule 70 (bit_and -> bit_and BitAnd equality .)
    Comma           reduce using rule 70 (bit_and -> bit_and BitAnd equality .)
    RBracket        reduce using rule 70 (bit_and -> bit_and BitAnd equality .)
    Colon           reduce using rule 70 (bit_and -> bit_and BitAnd equality .)
    NotEqual        shift and go to state 54
    Equal           shift and go to state 55


state 86

    (71) equality -> equality NotEqual relational .
    (73) relational -> relational . Less additive
    (74) relational -> relational . Greater additive
    (75) relational -> relational . LessEqual additive
    (76) relational -> relational . GreaterEqual additive

    NotEqual        reduce using rule 71 (equality -> equality NotEqual relational .)
    Equal           reduce using rule 71 (equality -> equality NotEqual relational .)
    BitAnd          reduce using rule 71 (equality -> equality NotEqual relational .)
    Xor             reduce using rule 71 (equality -> equality NotEqual relational .)
    BitOr           reduce using rule 71 (equality -> equality NotEqual relational .)
    And             reduce using rule 71 (equality -> equality NotEqual relational .)
    Question        reduce using rule 71 (equality -> equality NotEqual relational .)
    Or              reduce using rule 71 (equality -> equality NotEqual relational .)
    Semi            reduce using rule 71 (equality -> equality NotEqual relational .)
    RParen          reduce using rule 71 (equality -> equality NotEqual relational .)
    Comma           reduce using rule 71 (equality -> equality NotEqual relational .)
    RBracket        reduce using rule 71 (equality -> equality NotEqual relational .)
    Colon           reduce using rule 71 (equality -> equality NotEqual relational .)
    Less            shift and go to state 56
    Greater         shift and go to state 57
    LessEqual       shift and go to state 58
    GreaterEqual    shift and go to state 59


state 87

    (72) equality -> equality Equal relational .
    (73) relational -> relational . Less additive
    (74) relational -> relational . Greater additive
    (75) relational -> relational . LessEqual additive
    (76) relational -> relational . GreaterEqual additive

    NotEqual        reduce using rule 72 (equality -> equality Equal relational .)
    Equal           reduce using rule 72 (equality -> equality Equal relational .)
    BitAnd          reduce using rule 72 (equality -> equality Equal relational .)
    Xor             reduce using rule 72 (equality -> equality Equal relational .)
    BitOr           reduce using rule 72 (equality -> equality Equal relational .)
    And             reduce using rule 72 (equality -> equality Equal relational .)
    Question        reduce using rule 72 (equality -> equality Equal relational .)
    Or              reduce using rule 72 (equality -> equality Equal relational .)
    Semi            reduce using rule 72 (equality -> equality Equal relational .)
    RParen          reduce using rule 72 (equality -> equality Equal relational .)
    Comma           reduce using rule 72 (equality -> equality Equal relational .)
    RBracket        reduce using rule 72 (equality -> equality Equal relational .)
    Colon           reduce using rule 72 (equality -> equality Equal relational .)
    Less            shift and go to state 56
    Greater         shift and go to state 57
    LessEqual       shift and go to state 58
    GreaterEqual    shift and go to state 59


state 88

    (73) relational -> relational Less additive .
    (77) additive -> additive . Plus multiplicative
    (78) additive -> additive . Minus multiplicative

    Less            reduce using rule 73 (relational -> relational Less additive .)
    Greater         reduce using rule 73 (relational -> relational Less additive .)
    LessEqual       reduce using rule 73 (relational -> relational Less additive .)
    GreaterEqual    reduce using rule 73 (relational -> relational Less additive .)
    NotEqual        reduce using rule 73 (relational -> relational Less additive .)
    Equal           reduce using rule 73 (relational -> relational Less additive .)
    BitAnd          reduce using rule 73 (relational -> relational Less additive .)
    Xor             reduce using rule 73 (relational -> relational Less additive .)
    BitOr           reduce using rule 73 (relational -> relational Less additive .)
    And             reduce using rule 73 (relational -> relational Less additive .)
    Question        reduce using rule 73 (relational -> relational Less additive .)
    Or              reduce using rule 73 (relational -> relational Less additive .)
    Semi            reduce using rule 73 (relational -> relational Less additive .)
    RParen          reduce using rule 73 (relational -> relational Less additive .)
    Comma           reduce using rule 73 (relational -> relational Less additive .)
    RBracket        reduce using rule 73 (relational -> relational Less additive .)
    Colon           reduce using rule 73 (relational -> relational Less additive .)
    Plus            shift and go to state 60
    Minus           shift and go to state 61


state 89

    (74) relational -> relational Greater additive .
    (77) additive -> additive . Plus multiplicative
    (78) additive -> additive . Minus multiplicative

    Less            reduce using rule 74 (relational -> relational Greater additive .)
    Greater         reduce using rule 74 (relational -> relational Greater additive .)
    LessEqual       reduce using rule 74 (relational -> relational Greater additive .)
    GreaterEqual    reduce using rule 74 (relational -> relational Greater additive .)
    NotEqual        reduce using rule 74 (relational -> relational Greater additive .)
    Equal           reduce using rule 74 (relational -> relational Greater additive .)
    BitAnd          reduce using rule 74 (relational -> relational Greater additive .)
    Xor             reduce using rule 74 (relational -> relational Greater additive .)
    BitOr           reduce using rule 74 (relational -> relational Greater additive .)
    And             reduce using rule 74 (relational -> relational Greater additive .)
    Question        reduce using rule 74 (relational -> relational Greater additive .)
    Or              reduce using rule 74 (relational -> relational Greater additive .)
    Semi            reduce using rule 74 (relational -> relational Greater additive .)
    RParen          reduce using rule 74 (relational -> relational Greater additive .)
    Comma           reduce using rule 74 (relational -> relational Greater additive .)
    RBracket        reduce using rule 74 (relational -> relational Greater additive .)
    Colon           reduce using rule 74 (relational -> relational Greater additive .)
    Plus            shift and go to state 60
    Minus           shift and go to state 61


state 90

    (75) relational -> relational LessEqual additive .
    (77) additive -> additive . Plus multiplicative
    (78) additive -> additive . Minus multiplicative

    Less            reduce using rule 75 (relational -> relational LessEqual additive .)
    Greater         reduce using rule 75 (relational -> relational LessEqual additive .)
    LessEqual       reduce using rule 75 (relational -> relational LessEqual additive .)
    GreaterEqual    reduce using rule 75 (relational -> relational LessEqual additive .)
    NotEqual        reduce using rule 75 (relational -> relational LessEqual additive .)
    Equal           reduce using rule 75 (relational -> relational LessEqual additive .)
    BitAnd          reduce using rule 75 (relational -> relational LessEqual additive .)
    Xor             reduce using rule 75 (relational -> relational LessEqual additive .)
    BitOr           reduce using rule 75 (relational -> relational LessEqual additive .)
    And             reduce using rule 75 (relational -> relational LessEqual additive .)
    Question        reduce using rule 75 (relational -> relational LessEqual additive .)
    Or              reduce using rule 75 (relational -> relational LessEqual additive .)
    Semi            reduce using rule 75 (relational -> relational LessEqual additive .)
    RParen          reduce using rule 75 (relational -> relational LessEqual additive .)
    Comma           reduce using rule 75 (relational -> relational LessEqual additive .)
    RBracket        reduce using rule 75 (relational -> relational LessEqual additive .)
    Colon           reduce using rule 75 (relational -> relational LessEqual additive .)
    Plus            shift and go to state 60
    Minus           shift and go to state 61


state 91

    (76) relational -> relational GreaterEqual additive .
    (77) additive -> additive . Plus multiplicative
    (78) additive -> additive . Minus multiplicative

    Less            reduce using rule 76 (relational -> relational GreaterEqual additive .)
    Greater         reduce using rule 76 (relational -> relational GreaterEqual additive .)
    LessEqual       reduce using rule 76 (relational -> relational GreaterEqual additive .)
    GreaterEqual    reduce using rule 76 (relational -> relational GreaterEqual additive .)
    NotEqual        reduce using rule 76 (relational -> relational GreaterEqual additive .)
    Equal           reduce using rule 76 (relational -> relational GreaterEqual additive .)
    BitAnd          reduce using rule 76 (relational -> relational GreaterEqual additive .)
    Xor             reduce using rule 76 (relational -> relational GreaterEqual additive .)
    BitOr           reduce using rule 76 (relational -> relational GreaterEqual additive .)
    And             reduce using rule 76 (relational -> relational GreaterEqual additive .)
    Question        reduce using rule 76 (relational -> relational GreaterEqual additive .)
    Or              reduce using rule 76 (relational -> relational GreaterEqual additive .)
    Semi            reduce using rule 76 (relational -> relational GreaterEqual additive .)
    RParen          reduce using rule 76 (relational -> relational GreaterEqual additive .)
    Comma           reduce using rule 76 (relational -> relational GreaterEqual additive .)
    RBracket        reduce using rule 76 (relational -> relational GreaterEqual additive .)
    Colon           reduce using rule 76 (relational -> relational GreaterEqual additive .)
    Plus            shift and go to state 60
    Minus           shift and go to state 61


state 92

    (77) additive -> additive Plus multiplicative .
    (79) multiplicative -> multiplicative . Mul unary
    (80) multiplicative -> multiplicative . Div unary
    (81) multiplicative -> multiplicative . Mod unary

    Plus            reduce using rule 77 (additive -> additive Plus multiplicative .)
    Minus           reduce using rule 77 (additive -> additive Plus multiplicative .)
    Less            reduce using rule 77 (additive -> additive Plus multiplicative .)
    Greater         reduce using rule 77 (additive -> additive Plus multiplicative .)
    LessEqual       reduce using rule 77 (additive -> additive Plus multiplicative .)
    GreaterEqual    reduce using rule 77 (additive -> additive Plus multiplicative .)
    NotEqual        reduce using rule 77 (additive -> additive Plus multiplicative .)
    Equal           reduce using rule 77 (additive -> additive Plus multiplicative .)
    BitAnd          reduce using rule 77 (additive -> additive Plus multiplicative .)
    Xor             reduce using rule 77 (additive -> additive Plus multiplicative .)
    BitOr           reduce using rule 77 (additive -> additive Plus multiplicative .)
    And             reduce using rule 77 (additive -> additive Plus multiplicative .)
    Question        reduce using rule 77 (additive -> additive Plus multiplicative .)
    Or              reduce using rule 77 (additive -> additive Plus multiplicative .)
    Semi            reduce using rule 77 (additive -> additive Plus multiplicative .)
    RParen          reduce using rule 77 (additive -> additive Plus multiplicative .)
    Comma           reduce using rule 77 (additive -> additive Plus multiplicative .)
    RBracket        reduce using rule 77 (additive -> additive Plus multiplicative .)
    Colon           reduce using rule 77 (additive -> additive Plus multiplicative .)
    Mul             shift and go to state 62
    Div             shift and go to state 63
    Mod             shift and go to state 64


state 93

    (78) additive -> additive Minus multiplicative .
    (79) multiplicative -> multiplicative . Mul unary
    (80) multiplicative -> multiplicative . Div unary
    (81) multiplicative -> multiplicative . Mod unary

    Plus            reduce using rule 78 (additive -> additive Minus multiplicative .)
    Minus           reduce using rule 78 (additive -> additive Minus multiplicative .)
    Less            reduce using rule 78 (additive -> additive Minus multiplicative .)
    Greater         reduce using rule 78 (additive -> additive Minus multiplicative .)
    LessEqual       reduce using rule 78 (additive -> additive Minus multiplicative .)
    GreaterEqual    reduce using rule 78 (additive -> additive Minus multiplicative .)
    NotEqual        reduce using rule 78 (additive -> additive Minus multiplicative .)
    Equal           reduce using rule 78 (additive -> additive Minus multiplicative .)
    BitAnd          reduce using rule 78 (additive -> additive Minus multiplicative .)
    Xor             reduce using rule 78 (additive -> additive Minus multiplicative .)
    BitOr           reduce using rule 78 (additive -> additive Minus multiplicative .)
    And             reduce using rule 78 (additive -> additive Minus multiplicative .)
    Question        reduce using rule 78 (additive -> additive Minus multiplicative .)
    Or              reduce using rule 78 (additive -> additive Minus multiplicative .)
    Semi            reduce using rule 78 (additive -> additive Minus multiplicative .)
    RParen          reduce using rule 78 (additive -> additive Minus multiplicative .)
    Comma           reduce using rule 78 (additive -> additive Minus multiplicative .)
    RBracket        reduce using rule 78 (additive -> additive Minus multiplicative .)
    Colon           reduce using rule 78 (additive -> additive Minus multiplicative .)
    Mul             shift and go to state 62
    Div             shift and go to state 63
    Mod             shift and go to state 64


state 94

    (79) multiplicative -> multiplicative Mul unary .

    Mul             reduce using rule 79 (multiplicative -> multiplicative Mul unary .)
    Div             reduce using rule 79 (multiplicative -> multiplicative Mul unary .)
    Mod             reduce using rule 79 (multiplicative -> multiplicative Mul unary .)
    Plus            reduce using rule 79 (multiplicative -> multiplicative Mul unary .)
    Minus           reduce using rule 79 (multiplicative -> multiplicative Mul unary .)
    Less            reduce using rule 79 (multiplicative -> multiplicative Mul unary .)
    Greater         reduce using rule 79 (multiplicative -> multiplicative Mul unary .)
    LessEqual       reduce using rule 79 (multiplicative -> multiplicative Mul unary .)
    GreaterEqual    reduce using rule 79 (multiplicative -> multiplicative Mul unary .)
    NotEqual        reduce using rule 79 (multiplicative -> multiplicative Mul unary .)
    Equal           reduce using rule 79 (multiplicative -> multiplicative Mul unary .)
    BitAnd          reduce using rule 79 (multiplicative -> multiplicative Mul unary .)
    Xor             reduce using rule 79 (multiplicative -> multiplicative Mul unary .)
    BitOr           reduce using rule 79 (multiplicative -> multiplicative Mul unary .)
    And             reduce using rule 79 (multiplicative -> multiplicative Mul unary .)
    Question        reduce using rule 79 (multiplicative -> multiplicative Mul unary .)
    Or              reduce using rule 79 (multiplicative -> multiplicative Mul unary .)
    Semi            reduce using rule 79 (multiplicative -> multiplicative Mul unary .)
    RParen          reduce using rule 79 (multiplicative -> multiplicative Mul unary .)
    Comma           reduce using rule 79 (multiplicative -> multiplicative Mul unary .)
    RBracket        reduce using rule 79 (multiplicative -> multiplicative Mul unary .)
    Colon           reduce using rule 79 (multiplicative -> multiplicative Mul unary .)


state 95

    (80) multiplicative -> multiplicative Div unary .

    Mul             reduce using rule 80 (multiplicative -> multiplicative Div unary .)
    Div             reduce using rule 80 (multiplicative -> multiplicative Div unary .)
    Mod             reduce using rule 80 (multiplicative -> multiplicative Div unary .)
    Plus            reduce using rule 80 (multiplicative -> multiplicative Div unary .)
    Minus           reduce using rule 80 (multiplicative -> multiplicative Div unary .)
    Less            reduce using rule 80 (multiplicative -> multiplicative Div unary .)
    Greater         reduce using rule 80 (multiplicative -> multiplicative Div unary .)
    LessEqual       reduce using rule 80 (multiplicative -> multiplicative Div unary .)
    GreaterEqual    reduce using rule 80 (multiplicative -> multiplicative Div unary .)
    NotEqual        reduce using rule 80 (multiplicative -> multiplicative Div unary .)
    Equal           reduce using rule 80 (multiplicative -> multiplicative Div unary .)
    BitAnd          reduce using rule 80 (multiplicative -> multiplicative Div unary .)
    Xor             reduce using rule 80 (multiplicative -> multiplicative Div unary .)
    BitOr           reduce using rule 80 (multiplicative -> multiplicative Div unary .)
    And             reduce using rule 80 (multiplicative -> multiplicative Div unary .)
    Question        reduce using rule 80 (multiplicative -> multiplicative Div unary .)
    Or              reduce using rule 80 (multiplicative -> multiplicative Div unary .)
    Semi            reduce using rule 80 (multiplicative -> multiplicative Div unary .)
    RParen          reduce using rule 80 (multiplicative -> multiplicative Div unary .)
    Comma           reduce using rule 80 (multiplicative -> multiplicative Div unary .)
    RBracket        reduce using rule 80 (multiplicative -> multiplicative Div unary .)
    Colon           reduce using rule 80 (multiplicative -> multiplicative Div unary .)


state 96

    (81) multiplicative -> multiplicative Mod unary .

    Mul             reduce using rule 81 (multiplicative -> multiplicative Mod unary .)
    Div             reduce using rule 81 (multiplicative -> multiplicative Mod unary .)
    Mod             reduce using rule 81 (multiplicative -> multiplicative Mod unary .)
    Plus            reduce using rule 81 (multiplicative -> multiplicative Mod unary .)
    Minus           reduce using rule 81 (multiplicative -> multiplicative Mod unary .)
    Less            reduce using rule 81 (multiplicative -> multiplicative Mod unary .)
    Greater         reduce using rule 81 (multiplicative -> multiplicative Mod unary .)
    LessEqual       reduce using rule 81 (multiplicative -> multiplicative Mod unary .)
    GreaterEqual    reduce using rule 81 (multiplicative -> multiplicative Mod unary .)
    NotEqual        reduce using rule 81 (multiplicative -> multiplicative Mod unary .)
    Equal           reduce using rule 81 (multiplicative -> multiplicative Mod unary .)
    BitAnd          reduce using rule 81 (multiplicative -> multiplicative Mod unary .)
    Xor             reduce using rule 81 (multiplicative -> multiplicative Mod unary .)
    BitOr           reduce using rule 81 (multiplicative -> multiplicative Mod unary .)
    And             reduce using rule 81 (multiplicative -> multiplicative Mod unary .)
    Question        reduce using rule 81 (multiplicative -> multiplicative Mod unary .)
    Or              reduce using rule 81 (multiplicative -> multiplicative Mod unary .)
    Semi            reduce using rule 81 (multiplicative -> multiplicative Mod unary .)
    RParen          reduce using rule 81 (multiplicative -> multiplicative Mod unary .)
    Comma           reduce using rule 81 (multiplicative -> multiplicative Mod unary .)
    RBracket        reduce using rule 81 (multiplicative -> multiplicative Mod unary .)
    Colon           reduce using rule 81 (multiplicative -> multiplicative Mod unary .)


state 97

    (85) primary -> LParen expression RParen .

    Mul             reduce using rule 85 (primary -> LParen expression RParen .)
    Div             reduce using rule 85 (primary -> LParen expression RParen .)
    Mod             reduce using rule 85 (primary -> LParen expression RParen .)
    Plus            reduce using rule 85 (primary -> LParen expression RParen .)
    Minus           reduce using rule 85 (primary -> LParen expression RParen .)
    Less            reduce using rule 85 (primary -> LParen expression RParen .)
    Greater         reduce using rule 85 (primary -> LParen expression RParen .)
    LessEqual       reduce using rule 85 (primary -> LParen expression RParen .)
    GreaterEqual    reduce using rule 85 (primary -> LParen expression RParen .)
    NotEqual        reduce using rule 85 (primary -> LParen expression RParen .)
    Equal           reduce using rule 85 (primary -> LParen expression RParen .)
    BitAnd          reduce using rule 85 (primary -> LParen expression RParen .)
    Xor             reduce using rule 85 (primary -> LParen expression RParen .)
    BitOr           reduce using rule 85 (primary -> LParen expression RParen .)
    And             reduce using rule 85 (primary -> LParen expression RParen .)
    Question        reduce using rule 85 (primary -> LParen expression RParen .)
    Or              reduce using rule 85 (primary -> LParen expression RParen .)
    Semi            reduce using rule 85 (primary -> LParen expression RParen .)
    RParen          reduce using rule 85 (primary -> LParen expression RParen .)
    Comma           reduce using rule 85 (primary -> LParen expression RParen .)
    RBracket        reduce using rule 85 (primary -> LParen expression RParen .)
    Colon           reduce using rule 85 (primary -> LParen expression RParen .)


state 98

    (34) arr_dim_list -> LBracket Integer RBracket arr_dim_list .

    Semi            reduce using rule 34 (arr_dim_list -> LBracket Integer RBracket arr_dim_list .)


state 99

    (7) function -> type Identifier LParen Parameter RParen LBrace block . RBrace
    (8) block -> block . block_item
    (10) block_item -> . statement
    (11) block_item -> . declaration Semi
    (12) statement -> . statement_matched
    (13) statement -> . statement_unmatched
    (32) declaration -> . type Identifier
    (33) declaration -> . type Identifier Assign expression
    (36) declaration -> . type Identifier arr_dim_list
    (14) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (17) statement_matched -> . While LParen expression RParen statement_matched
    (19) statement_matched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
    (20) statement_matched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched
    (23) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (25) statement_matched -> . Return expression Semi
    (26) statement_matched -> . opt_expression Semi
    (27) statement_matched -> . LBrace block RBrace
    (28) statement_matched -> . Break Semi
    (29) statement_matched -> . Continue Semi
    (15) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (16) statement_unmatched -> . If LParen expression RParen statement
    (18) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (21) statement_unmatched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched
    (22) statement_unmatched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched
    (24) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (6) type -> . Int
    (30) opt_expression -> . expression
    (31) opt_expression -> . empty
    (44) expression -> . assignment
    (4) empty -> .
    (45) assignment -> . conditional
    (64) assignment -> . Identifier Assign expression
    (65) assignment -> . arr_ref Assign expression
    (46) conditional -> . logical_or
    (82) conditional -> . logical_or Question expression Colon conditional
    (63) arr_ref -> . Identifier arr_idx_list
    (47) logical_or -> . logical_and
    (66) logical_or -> . logical_or Or logical_and
    (48) logical_and -> . bit_or
    (67) logical_and -> . logical_and And bit_or
    (49) bit_or -> . xor
    (68) bit_or -> . bit_or BitOr xor
    (50) xor -> . bit_and
    (69) xor -> . xor Xor bit_and
    (51) bit_and -> . equality
    (70) bit_and -> . bit_and BitAnd equality
    (52) equality -> . relational
    (71) equality -> . equality NotEqual relational
    (72) equality -> . equality Equal relational
    (53) relational -> . additive
    (73) relational -> . relational Less additive
    (74) relational -> . relational Greater additive
    (75) relational -> . relational LessEqual additive
    (76) relational -> . relational GreaterEqual additive
    (54) additive -> . multiplicative
    (77) additive -> . additive Plus multiplicative
    (78) additive -> . additive Minus multiplicative
    (55) multiplicative -> . unary
    (79) multiplicative -> . multiplicative Mul unary
    (80) multiplicative -> . multiplicative Div unary
    (81) multiplicative -> . multiplicative Mod unary
    (56) unary -> . postfix
    (58) unary -> . Minus unary
    (59) unary -> . BitNot unary
    (60) unary -> . Not unary
    (37) postfix -> . Identifier LParen call_para RParen
    (57) postfix -> . primary
    (83) primary -> . Integer
    (84) primary -> . Identifier
    (85) primary -> . LParen expression RParen
    (86) primary -> . arr_ref

    RBrace          shift and go to state 107
    If              shift and go to state 114
    While           shift and go to state 115
    For             shift and go to state 116
    Do              shift and go to state 118
    Return          shift and go to state 119
    LBrace          shift and go to state 106
    Break           shift and go to state 120
    Continue        shift and go to state 121
    Int             shift and go to state 6
    Semi            reduce using rule 4 (empty -> .)
    Identifier      shift and go to state 17
    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Integer         shift and go to state 38
    LParen          shift and go to state 36

    type                           shift and go to state 105
    block_item                     shift and go to state 108
    statement                      shift and go to state 109
    declaration                    shift and go to state 110
    statement_matched              shift and go to state 111
    statement_unmatched            shift and go to state 112
    expression                     shift and go to state 113
    opt_expression                 shift and go to state 117
    empty                          shift and go to state 122
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    arr_ref                        shift and go to state 21
    logical_or                     shift and go to state 22
    logical_and                    shift and go to state 23
    bit_or                         shift and go to state 24
    xor                            shift and go to state 25
    bit_and                        shift and go to state 26
    equality                       shift and go to state 27
    relational                     shift and go to state 28
    additive                       shift and go to state 29
    multiplicative                 shift and go to state 30
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 37

state 100

    (9) block -> empty .

    RBrace          reduce using rule 9 (block -> empty .)
    If              reduce using rule 9 (block -> empty .)
    While           reduce using rule 9 (block -> empty .)
    For             reduce using rule 9 (block -> empty .)
    Do              reduce using rule 9 (block -> empty .)
    Return          reduce using rule 9 (block -> empty .)
    LBrace          reduce using rule 9 (block -> empty .)
    Break           reduce using rule 9 (block -> empty .)
    Continue        reduce using rule 9 (block -> empty .)
    Int             reduce using rule 9 (block -> empty .)
    Identifier      reduce using rule 9 (block -> empty .)
    Minus           reduce using rule 9 (block -> empty .)
    BitNot          reduce using rule 9 (block -> empty .)
    Not             reduce using rule 9 (block -> empty .)
    Integer         reduce using rule 9 (block -> empty .)
    LParen          reduce using rule 9 (block -> empty .)
    Semi            reduce using rule 9 (block -> empty .)


state 101

    (37) postfix -> Identifier LParen call_para RParen .

    Mul             reduce using rule 37 (postfix -> Identifier LParen call_para RParen .)
    Div             reduce using rule 37 (postfix -> Identifier LParen call_para RParen .)
    Mod             reduce using rule 37 (postfix -> Identifier LParen call_para RParen .)
    Plus            reduce using rule 37 (postfix -> Identifier LParen call_para RParen .)
    Minus           reduce using rule 37 (postfix -> Identifier LParen call_para RParen .)
    Less            reduce using rule 37 (postfix -> Identifier LParen call_para RParen .)
    Greater         reduce using rule 37 (postfix -> Identifier LParen call_para RParen .)
    LessEqual       reduce using rule 37 (postfix -> Identifier LParen call_para RParen .)
    GreaterEqual    reduce using rule 37 (postfix -> Identifier LParen call_para RParen .)
    NotEqual        reduce using rule 37 (postfix -> Identifier LParen call_para RParen .)
    Equal           reduce using rule 37 (postfix -> Identifier LParen call_para RParen .)
    BitAnd          reduce using rule 37 (postfix -> Identifier LParen call_para RParen .)
    Xor             reduce using rule 37 (postfix -> Identifier LParen call_para RParen .)
    BitOr           reduce using rule 37 (postfix -> Identifier LParen call_para RParen .)
    And             reduce using rule 37 (postfix -> Identifier LParen call_para RParen .)
    Question        reduce using rule 37 (postfix -> Identifier LParen call_para RParen .)
    Or              reduce using rule 37 (postfix -> Identifier LParen call_para RParen .)
    Semi            reduce using rule 37 (postfix -> Identifier LParen call_para RParen .)
    RParen          reduce using rule 37 (postfix -> Identifier LParen call_para RParen .)
    Comma           reduce using rule 37 (postfix -> Identifier LParen call_para RParen .)
    RBracket        reduce using rule 37 (postfix -> Identifier LParen call_para RParen .)
    Colon           reduce using rule 37 (postfix -> Identifier LParen call_para RParen .)


state 102

    (40) call_para -> call_para Comma . call_para
    (38) call_para -> . expression
    (39) call_para -> . empty
    (40) call_para -> . call_para Comma call_para
    (44) expression -> . assignment
    (4) empty -> .
    (45) assignment -> . conditional
    (64) assignment -> . Identifier Assign expression
    (65) assignment -> . arr_ref Assign expression
    (46) conditional -> . logical_or
    (82) conditional -> . logical_or Question expression Colon conditional
    (63) arr_ref -> . Identifier arr_idx_list
    (47) logical_or -> . logical_and
    (66) logical_or -> . logical_or Or logical_and
    (48) logical_and -> . bit_or
    (67) logical_and -> . logical_and And bit_or
    (49) bit_or -> . xor
    (68) bit_or -> . bit_or BitOr xor
    (50) xor -> . bit_and
    (69) xor -> . xor Xor bit_and
    (51) bit_and -> . equality
    (70) bit_and -> . bit_and BitAnd equality
    (52) equality -> . relational
    (71) equality -> . equality NotEqual relational
    (72) equality -> . equality Equal relational
    (53) relational -> . additive
    (73) relational -> . relational Less additive
    (74) relational -> . relational Greater additive
    (75) relational -> . relational LessEqual additive
    (76) relational -> . relational GreaterEqual additive
    (54) additive -> . multiplicative
    (77) additive -> . additive Plus multiplicative
    (78) additive -> . additive Minus multiplicative
    (55) multiplicative -> . unary
    (79) multiplicative -> . multiplicative Mul unary
    (80) multiplicative -> . multiplicative Div unary
    (81) multiplicative -> . multiplicative Mod unary
    (56) unary -> . postfix
    (58) unary -> . Minus unary
    (59) unary -> . BitNot unary
    (60) unary -> . Not unary
    (37) postfix -> . Identifier LParen call_para RParen
    (57) postfix -> . primary
    (83) primary -> . Integer
    (84) primary -> . Identifier
    (85) primary -> . LParen expression RParen
    (86) primary -> . arr_ref

    Comma           reduce using rule 4 (empty -> .)
    RParen          reduce using rule 4 (empty -> .)
    Identifier      shift and go to state 17
    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Integer         shift and go to state 38
    LParen          shift and go to state 36

    call_para                      shift and go to state 123
    expression                     shift and go to state 76
    empty                          shift and go to state 77
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    arr_ref                        shift and go to state 21
    logical_or                     shift and go to state 22
    logical_and                    shift and go to state 23
    bit_or                         shift and go to state 24
    xor                            shift and go to state 25
    bit_and                        shift and go to state 26
    equality                       shift and go to state 27
    relational                     shift and go to state 28
    additive                       shift and go to state 29
    multiplicative                 shift and go to state 30
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 37

state 103

    (61) arr_idx_list -> LBracket expression RBracket . arr_idx_list
    (62) arr_idx_list -> LBracket expression RBracket .
    (61) arr_idx_list -> . LBracket expression RBracket arr_idx_list
    (62) arr_idx_list -> . LBracket expression RBracket

    Assign          reduce using rule 62 (arr_idx_list -> LBracket expression RBracket .)
    Mul             reduce using rule 62 (arr_idx_list -> LBracket expression RBracket .)
    Div             reduce using rule 62 (arr_idx_list -> LBracket expression RBracket .)
    Mod             reduce using rule 62 (arr_idx_list -> LBracket expression RBracket .)
    Plus            reduce using rule 62 (arr_idx_list -> LBracket expression RBracket .)
    Minus           reduce using rule 62 (arr_idx_list -> LBracket expression RBracket .)
    Less            reduce using rule 62 (arr_idx_list -> LBracket expression RBracket .)
    Greater         reduce using rule 62 (arr_idx_list -> LBracket expression RBracket .)
    LessEqual       reduce using rule 62 (arr_idx_list -> LBracket expression RBracket .)
    GreaterEqual    reduce using rule 62 (arr_idx_list -> LBracket expression RBracket .)
    NotEqual        reduce using rule 62 (arr_idx_list -> LBracket expression RBracket .)
    Equal           reduce using rule 62 (arr_idx_list -> LBracket expression RBracket .)
    BitAnd          reduce using rule 62 (arr_idx_list -> LBracket expression RBracket .)
    Xor             reduce using rule 62 (arr_idx_list -> LBracket expression RBracket .)
    BitOr           reduce using rule 62 (arr_idx_list -> LBracket expression RBracket .)
    And             reduce using rule 62 (arr_idx_list -> LBracket expression RBracket .)
    Question        reduce using rule 62 (arr_idx_list -> LBracket expression RBracket .)
    Or              reduce using rule 62 (arr_idx_list -> LBracket expression RBracket .)
    Semi            reduce using rule 62 (arr_idx_list -> LBracket expression RBracket .)
    RParen          reduce using rule 62 (arr_idx_list -> LBracket expression RBracket .)
    Comma           reduce using rule 62 (arr_idx_list -> LBracket expression RBracket .)
    RBracket        reduce using rule 62 (arr_idx_list -> LBracket expression RBracket .)
    Colon           reduce using rule 62 (arr_idx_list -> LBracket expression RBracket .)
    LBracket        shift and go to state 46

    arr_idx_list                   shift and go to state 124

state 104

    (82) conditional -> logical_or Question expression Colon . conditional
    (46) conditional -> . logical_or
    (82) conditional -> . logical_or Question expression Colon conditional
    (47) logical_or -> . logical_and
    (66) logical_or -> . logical_or Or logical_and
    (48) logical_and -> . bit_or
    (67) logical_and -> . logical_and And bit_or
    (49) bit_or -> . xor
    (68) bit_or -> . bit_or BitOr xor
    (50) xor -> . bit_and
    (69) xor -> . xor Xor bit_and
    (51) bit_and -> . equality
    (70) bit_and -> . bit_and BitAnd equality
    (52) equality -> . relational
    (71) equality -> . equality NotEqual relational
    (72) equality -> . equality Equal relational
    (53) relational -> . additive
    (73) relational -> . relational Less additive
    (74) relational -> . relational Greater additive
    (75) relational -> . relational LessEqual additive
    (76) relational -> . relational GreaterEqual additive
    (54) additive -> . multiplicative
    (77) additive -> . additive Plus multiplicative
    (78) additive -> . additive Minus multiplicative
    (55) multiplicative -> . unary
    (79) multiplicative -> . multiplicative Mul unary
    (80) multiplicative -> . multiplicative Div unary
    (81) multiplicative -> . multiplicative Mod unary
    (56) unary -> . postfix
    (58) unary -> . Minus unary
    (59) unary -> . BitNot unary
    (60) unary -> . Not unary
    (37) postfix -> . Identifier LParen call_para RParen
    (57) postfix -> . primary
    (83) primary -> . Integer
    (84) primary -> . Identifier
    (85) primary -> . LParen expression RParen
    (86) primary -> . arr_ref
    (63) arr_ref -> . Identifier arr_idx_list

    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Identifier      shift and go to state 66
    Integer         shift and go to state 38
    LParen          shift and go to state 36

    logical_or                     shift and go to state 22
    conditional                    shift and go to state 125
    logical_and                    shift and go to state 23
    bit_or                         shift and go to state 24
    xor                            shift and go to state 25
    bit_and                        shift and go to state 26
    equality                       shift and go to state 27
    relational                     shift and go to state 28
    additive                       shift and go to state 29
    multiplicative                 shift and go to state 30
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 37
    arr_ref                        shift and go to state 67

state 105

    (32) declaration -> type . Identifier
    (33) declaration -> type . Identifier Assign expression
    (36) declaration -> type . Identifier arr_dim_list

    Identifier      shift and go to state 126


state 106

    (27) statement_matched -> LBrace . block RBrace
    (8) block -> . block block_item
    (9) block -> . empty
    (4) empty -> .

    RBrace          reduce using rule 4 (empty -> .)
    If              reduce using rule 4 (empty -> .)
    While           reduce using rule 4 (empty -> .)
    For             reduce using rule 4 (empty -> .)
    Do              reduce using rule 4 (empty -> .)
    Return          reduce using rule 4 (empty -> .)
    LBrace          reduce using rule 4 (empty -> .)
    Break           reduce using rule 4 (empty -> .)
    Continue        reduce using rule 4 (empty -> .)
    Int             reduce using rule 4 (empty -> .)
    Identifier      reduce using rule 4 (empty -> .)
    Minus           reduce using rule 4 (empty -> .)
    BitNot          reduce using rule 4 (empty -> .)
    Not             reduce using rule 4 (empty -> .)
    Integer         reduce using rule 4 (empty -> .)
    LParen          reduce using rule 4 (empty -> .)
    Semi            reduce using rule 4 (empty -> .)

    block                          shift and go to state 127
    empty                          shift and go to state 100

state 107

    (7) function -> type Identifier LParen Parameter RParen LBrace block RBrace .

    Int             reduce using rule 7 (function -> type Identifier LParen Parameter RParen LBrace block RBrace .)
    $end            reduce using rule 7 (function -> type Identifier LParen Parameter RParen LBrace block RBrace .)


state 108

    (8) block -> block block_item .

    RBrace          reduce using rule 8 (block -> block block_item .)
    If              reduce using rule 8 (block -> block block_item .)
    While           reduce using rule 8 (block -> block block_item .)
    For             reduce using rule 8 (block -> block block_item .)
    Do              reduce using rule 8 (block -> block block_item .)
    Return          reduce using rule 8 (block -> block block_item .)
    LBrace          reduce using rule 8 (block -> block block_item .)
    Break           reduce using rule 8 (block -> block block_item .)
    Continue        reduce using rule 8 (block -> block block_item .)
    Int             reduce using rule 8 (block -> block block_item .)
    Identifier      reduce using rule 8 (block -> block block_item .)
    Minus           reduce using rule 8 (block -> block block_item .)
    BitNot          reduce using rule 8 (block -> block block_item .)
    Not             reduce using rule 8 (block -> block block_item .)
    Integer         reduce using rule 8 (block -> block block_item .)
    LParen          reduce using rule 8 (block -> block block_item .)
    Semi            reduce using rule 8 (block -> block block_item .)


state 109

    (10) block_item -> statement .

    RBrace          reduce using rule 10 (block_item -> statement .)
    If              reduce using rule 10 (block_item -> statement .)
    While           reduce using rule 10 (block_item -> statement .)
    For             reduce using rule 10 (block_item -> statement .)
    Do              reduce using rule 10 (block_item -> statement .)
    Return          reduce using rule 10 (block_item -> statement .)
    LBrace          reduce using rule 10 (block_item -> statement .)
    Break           reduce using rule 10 (block_item -> statement .)
    Continue        reduce using rule 10 (block_item -> statement .)
    Int             reduce using rule 10 (block_item -> statement .)
    Identifier      reduce using rule 10 (block_item -> statement .)
    Minus           reduce using rule 10 (block_item -> statement .)
    BitNot          reduce using rule 10 (block_item -> statement .)
    Not             reduce using rule 10 (block_item -> statement .)
    Integer         reduce using rule 10 (block_item -> statement .)
    LParen          reduce using rule 10 (block_item -> statement .)
    Semi            reduce using rule 10 (block_item -> statement .)


state 110

    (11) block_item -> declaration . Semi

    Semi            shift and go to state 128


state 111

    (12) statement -> statement_matched .

    RBrace          reduce using rule 12 (statement -> statement_matched .)
    If              reduce using rule 12 (statement -> statement_matched .)
    While           reduce using rule 12 (statement -> statement_matched .)
    For             reduce using rule 12 (statement -> statement_matched .)
    Do              reduce using rule 12 (statement -> statement_matched .)
    Return          reduce using rule 12 (statement -> statement_matched .)
    LBrace          reduce using rule 12 (statement -> statement_matched .)
    Break           reduce using rule 12 (statement -> statement_matched .)
    Continue        reduce using rule 12 (statement -> statement_matched .)
    Int             reduce using rule 12 (statement -> statement_matched .)
    Identifier      reduce using rule 12 (statement -> statement_matched .)
    Minus           reduce using rule 12 (statement -> statement_matched .)
    BitNot          reduce using rule 12 (statement -> statement_matched .)
    Not             reduce using rule 12 (statement -> statement_matched .)
    Integer         reduce using rule 12 (statement -> statement_matched .)
    LParen          reduce using rule 12 (statement -> statement_matched .)
    Semi            reduce using rule 12 (statement -> statement_matched .)


state 112

    (13) statement -> statement_unmatched .

    RBrace          reduce using rule 13 (statement -> statement_unmatched .)
    If              reduce using rule 13 (statement -> statement_unmatched .)
    While           reduce using rule 13 (statement -> statement_unmatched .)
    For             reduce using rule 13 (statement -> statement_unmatched .)
    Do              reduce using rule 13 (statement -> statement_unmatched .)
    Return          reduce using rule 13 (statement -> statement_unmatched .)
    LBrace          reduce using rule 13 (statement -> statement_unmatched .)
    Break           reduce using rule 13 (statement -> statement_unmatched .)
    Continue        reduce using rule 13 (statement -> statement_unmatched .)
    Int             reduce using rule 13 (statement -> statement_unmatched .)
    Identifier      reduce using rule 13 (statement -> statement_unmatched .)
    Minus           reduce using rule 13 (statement -> statement_unmatched .)
    BitNot          reduce using rule 13 (statement -> statement_unmatched .)
    Not             reduce using rule 13 (statement -> statement_unmatched .)
    Integer         reduce using rule 13 (statement -> statement_unmatched .)
    LParen          reduce using rule 13 (statement -> statement_unmatched .)
    Semi            reduce using rule 13 (statement -> statement_unmatched .)


state 113

    (30) opt_expression -> expression .

    Semi            reduce using rule 30 (opt_expression -> expression .)
    RParen          reduce using rule 30 (opt_expression -> expression .)


state 114

    (14) statement_matched -> If . LParen expression RParen statement_matched Else statement_matched
    (15) statement_unmatched -> If . LParen expression RParen statement_matched Else statement_unmatched
    (16) statement_unmatched -> If . LParen expression RParen statement

    LParen          shift and go to state 129


state 115

    (17) statement_matched -> While . LParen expression RParen statement_matched
    (18) statement_unmatched -> While . LParen expression RParen statement_unmatched

    LParen          shift and go to state 130


state 116

    (19) statement_matched -> For . LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
    (20) statement_matched -> For . LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched
    (21) statement_unmatched -> For . LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched
    (22) statement_unmatched -> For . LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched

    LParen          shift and go to state 131


state 117

    (26) statement_matched -> opt_expression . Semi

    Semi            shift and go to state 132


state 118

    (23) statement_matched -> Do . statement_matched While LParen expression RParen Semi
    (24) statement_unmatched -> Do . statement_unmatched While LParen expression RParen Semi
    (14) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (17) statement_matched -> . While LParen expression RParen statement_matched
    (19) statement_matched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
    (20) statement_matched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched
    (23) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (25) statement_matched -> . Return expression Semi
    (26) statement_matched -> . opt_expression Semi
    (27) statement_matched -> . LBrace block RBrace
    (28) statement_matched -> . Break Semi
    (29) statement_matched -> . Continue Semi
    (15) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (16) statement_unmatched -> . If LParen expression RParen statement
    (18) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (21) statement_unmatched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched
    (22) statement_unmatched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched
    (24) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (30) opt_expression -> . expression
    (31) opt_expression -> . empty
    (44) expression -> . assignment
    (4) empty -> .
    (45) assignment -> . conditional
    (64) assignment -> . Identifier Assign expression
    (65) assignment -> . arr_ref Assign expression
    (46) conditional -> . logical_or
    (82) conditional -> . logical_or Question expression Colon conditional
    (63) arr_ref -> . Identifier arr_idx_list
    (47) logical_or -> . logical_and
    (66) logical_or -> . logical_or Or logical_and
    (48) logical_and -> . bit_or
    (67) logical_and -> . logical_and And bit_or
    (49) bit_or -> . xor
    (68) bit_or -> . bit_or BitOr xor
    (50) xor -> . bit_and
    (69) xor -> . xor Xor bit_and
    (51) bit_and -> . equality
    (70) bit_and -> . bit_and BitAnd equality
    (52) equality -> . relational
    (71) equality -> . equality NotEqual relational
    (72) equality -> . equality Equal relational
    (53) relational -> . additive
    (73) relational -> . relational Less additive
    (74) relational -> . relational Greater additive
    (75) relational -> . relational LessEqual additive
    (76) relational -> . relational GreaterEqual additive
    (54) additive -> . multiplicative
    (77) additive -> . additive Plus multiplicative
    (78) additive -> . additive Minus multiplicative
    (55) multiplicative -> . unary
    (79) multiplicative -> . multiplicative Mul unary
    (80) multiplicative -> . multiplicative Div unary
    (81) multiplicative -> . multiplicative Mod unary
    (56) unary -> . postfix
    (58) unary -> . Minus unary
    (59) unary -> . BitNot unary
    (60) unary -> . Not unary
    (37) postfix -> . Identifier LParen call_para RParen
    (57) postfix -> . primary
    (83) primary -> . Integer
    (84) primary -> . Identifier
    (85) primary -> . LParen expression RParen
    (86) primary -> . arr_ref

    If              shift and go to state 114
    While           shift and go to state 115
    For             shift and go to state 116
    Do              shift and go to state 118
    Return          shift and go to state 119
    LBrace          shift and go to state 106
    Break           shift and go to state 120
    Continue        shift and go to state 121
    Semi            reduce using rule 4 (empty -> .)
    Identifier      shift and go to state 17
    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Integer         shift and go to state 38
    LParen          shift and go to state 36

    statement_matched              shift and go to state 133
    expression                     shift and go to state 113
    statement_unmatched            shift and go to state 134
    opt_expression                 shift and go to state 117
    empty                          shift and go to state 122
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    arr_ref                        shift and go to state 21
    logical_or                     shift and go to state 22
    logical_and                    shift and go to state 23
    bit_or                         shift and go to state 24
    xor                            shift and go to state 25
    bit_and                        shift and go to state 26
    equality                       shift and go to state 27
    relational                     shift and go to state 28
    additive                       shift and go to state 29
    multiplicative                 shift and go to state 30
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 37

state 119

    (25) statement_matched -> Return . expression Semi
    (44) expression -> . assignment
    (45) assignment -> . conditional
    (64) assignment -> . Identifier Assign expression
    (65) assignment -> . arr_ref Assign expression
    (46) conditional -> . logical_or
    (82) conditional -> . logical_or Question expression Colon conditional
    (63) arr_ref -> . Identifier arr_idx_list
    (47) logical_or -> . logical_and
    (66) logical_or -> . logical_or Or logical_and
    (48) logical_and -> . bit_or
    (67) logical_and -> . logical_and And bit_or
    (49) bit_or -> . xor
    (68) bit_or -> . bit_or BitOr xor
    (50) xor -> . bit_and
    (69) xor -> . xor Xor bit_and
    (51) bit_and -> . equality
    (70) bit_and -> . bit_and BitAnd equality
    (52) equality -> . relational
    (71) equality -> . equality NotEqual relational
    (72) equality -> . equality Equal relational
    (53) relational -> . additive
    (73) relational -> . relational Less additive
    (74) relational -> . relational Greater additive
    (75) relational -> . relational LessEqual additive
    (76) relational -> . relational GreaterEqual additive
    (54) additive -> . multiplicative
    (77) additive -> . additive Plus multiplicative
    (78) additive -> . additive Minus multiplicative
    (55) multiplicative -> . unary
    (79) multiplicative -> . multiplicative Mul unary
    (80) multiplicative -> . multiplicative Div unary
    (81) multiplicative -> . multiplicative Mod unary
    (56) unary -> . postfix
    (58) unary -> . Minus unary
    (59) unary -> . BitNot unary
    (60) unary -> . Not unary
    (37) postfix -> . Identifier LParen call_para RParen
    (57) postfix -> . primary
    (83) primary -> . Integer
    (84) primary -> . Identifier
    (85) primary -> . LParen expression RParen
    (86) primary -> . arr_ref

    Identifier      shift and go to state 17
    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Integer         shift and go to state 38
    LParen          shift and go to state 36

    expression                     shift and go to state 135
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    arr_ref                        shift and go to state 21
    logical_or                     shift and go to state 22
    logical_and                    shift and go to state 23
    bit_or                         shift and go to state 24
    xor                            shift and go to state 25
    bit_and                        shift and go to state 26
    equality                       shift and go to state 27
    relational                     shift and go to state 28
    additive                       shift and go to state 29
    multiplicative                 shift and go to state 30
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 37

state 120

    (28) statement_matched -> Break . Semi

    Semi            shift and go to state 136


state 121

    (29) statement_matched -> Continue . Semi

    Semi            shift and go to state 137


state 122

    (31) opt_expression -> empty .

    Semi            reduce using rule 31 (opt_expression -> empty .)
    RParen          reduce using rule 31 (opt_expression -> empty .)


state 123

    (40) call_para -> call_para Comma call_para .
    (40) call_para -> call_para . Comma call_para

  ! shift/reduce conflict for Comma resolved as shift
    RParen          reduce using rule 40 (call_para -> call_para Comma call_para .)
    Comma           shift and go to state 102

  ! Comma           [ reduce using rule 40 (call_para -> call_para Comma call_para .) ]


state 124

    (61) arr_idx_list -> LBracket expression RBracket arr_idx_list .

    Assign          reduce using rule 61 (arr_idx_list -> LBracket expression RBracket arr_idx_list .)
    Mul             reduce using rule 61 (arr_idx_list -> LBracket expression RBracket arr_idx_list .)
    Div             reduce using rule 61 (arr_idx_list -> LBracket expression RBracket arr_idx_list .)
    Mod             reduce using rule 61 (arr_idx_list -> LBracket expression RBracket arr_idx_list .)
    Plus            reduce using rule 61 (arr_idx_list -> LBracket expression RBracket arr_idx_list .)
    Minus           reduce using rule 61 (arr_idx_list -> LBracket expression RBracket arr_idx_list .)
    Less            reduce using rule 61 (arr_idx_list -> LBracket expression RBracket arr_idx_list .)
    Greater         reduce using rule 61 (arr_idx_list -> LBracket expression RBracket arr_idx_list .)
    LessEqual       reduce using rule 61 (arr_idx_list -> LBracket expression RBracket arr_idx_list .)
    GreaterEqual    reduce using rule 61 (arr_idx_list -> LBracket expression RBracket arr_idx_list .)
    NotEqual        reduce using rule 61 (arr_idx_list -> LBracket expression RBracket arr_idx_list .)
    Equal           reduce using rule 61 (arr_idx_list -> LBracket expression RBracket arr_idx_list .)
    BitAnd          reduce using rule 61 (arr_idx_list -> LBracket expression RBracket arr_idx_list .)
    Xor             reduce using rule 61 (arr_idx_list -> LBracket expression RBracket arr_idx_list .)
    BitOr           reduce using rule 61 (arr_idx_list -> LBracket expression RBracket arr_idx_list .)
    And             reduce using rule 61 (arr_idx_list -> LBracket expression RBracket arr_idx_list .)
    Question        reduce using rule 61 (arr_idx_list -> LBracket expression RBracket arr_idx_list .)
    Or              reduce using rule 61 (arr_idx_list -> LBracket expression RBracket arr_idx_list .)
    Semi            reduce using rule 61 (arr_idx_list -> LBracket expression RBracket arr_idx_list .)
    RParen          reduce using rule 61 (arr_idx_list -> LBracket expression RBracket arr_idx_list .)
    Comma           reduce using rule 61 (arr_idx_list -> LBracket expression RBracket arr_idx_list .)
    RBracket        reduce using rule 61 (arr_idx_list -> LBracket expression RBracket arr_idx_list .)
    Colon           reduce using rule 61 (arr_idx_list -> LBracket expression RBracket arr_idx_list .)


state 125

    (82) conditional -> logical_or Question expression Colon conditional .

    Semi            reduce using rule 82 (conditional -> logical_or Question expression Colon conditional .)
    RParen          reduce using rule 82 (conditional -> logical_or Question expression Colon conditional .)
    Comma           reduce using rule 82 (conditional -> logical_or Question expression Colon conditional .)
    RBracket        reduce using rule 82 (conditional -> logical_or Question expression Colon conditional .)
    Colon           reduce using rule 82 (conditional -> logical_or Question expression Colon conditional .)


state 126

    (32) declaration -> type Identifier .
    (33) declaration -> type Identifier . Assign expression
    (36) declaration -> type Identifier . arr_dim_list
    (34) arr_dim_list -> . LBracket Integer RBracket arr_dim_list
    (35) arr_dim_list -> . LBracket Integer RBracket

    Semi            reduce using rule 32 (declaration -> type Identifier .)
    Assign          shift and go to state 11
    LBracket        shift and go to state 13

    arr_dim_list                   shift and go to state 12

state 127

    (27) statement_matched -> LBrace block . RBrace
    (8) block -> block . block_item
    (10) block_item -> . statement
    (11) block_item -> . declaration Semi
    (12) statement -> . statement_matched
    (13) statement -> . statement_unmatched
    (32) declaration -> . type Identifier
    (33) declaration -> . type Identifier Assign expression
    (36) declaration -> . type Identifier arr_dim_list
    (14) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (17) statement_matched -> . While LParen expression RParen statement_matched
    (19) statement_matched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
    (20) statement_matched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched
    (23) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (25) statement_matched -> . Return expression Semi
    (26) statement_matched -> . opt_expression Semi
    (27) statement_matched -> . LBrace block RBrace
    (28) statement_matched -> . Break Semi
    (29) statement_matched -> . Continue Semi
    (15) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (16) statement_unmatched -> . If LParen expression RParen statement
    (18) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (21) statement_unmatched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched
    (22) statement_unmatched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched
    (24) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (6) type -> . Int
    (30) opt_expression -> . expression
    (31) opt_expression -> . empty
    (44) expression -> . assignment
    (4) empty -> .
    (45) assignment -> . conditional
    (64) assignment -> . Identifier Assign expression
    (65) assignment -> . arr_ref Assign expression
    (46) conditional -> . logical_or
    (82) conditional -> . logical_or Question expression Colon conditional
    (63) arr_ref -> . Identifier arr_idx_list
    (47) logical_or -> . logical_and
    (66) logical_or -> . logical_or Or logical_and
    (48) logical_and -> . bit_or
    (67) logical_and -> . logical_and And bit_or
    (49) bit_or -> . xor
    (68) bit_or -> . bit_or BitOr xor
    (50) xor -> . bit_and
    (69) xor -> . xor Xor bit_and
    (51) bit_and -> . equality
    (70) bit_and -> . bit_and BitAnd equality
    (52) equality -> . relational
    (71) equality -> . equality NotEqual relational
    (72) equality -> . equality Equal relational
    (53) relational -> . additive
    (73) relational -> . relational Less additive
    (74) relational -> . relational Greater additive
    (75) relational -> . relational LessEqual additive
    (76) relational -> . relational GreaterEqual additive
    (54) additive -> . multiplicative
    (77) additive -> . additive Plus multiplicative
    (78) additive -> . additive Minus multiplicative
    (55) multiplicative -> . unary
    (79) multiplicative -> . multiplicative Mul unary
    (80) multiplicative -> . multiplicative Div unary
    (81) multiplicative -> . multiplicative Mod unary
    (56) unary -> . postfix
    (58) unary -> . Minus unary
    (59) unary -> . BitNot unary
    (60) unary -> . Not unary
    (37) postfix -> . Identifier LParen call_para RParen
    (57) postfix -> . primary
    (83) primary -> . Integer
    (84) primary -> . Identifier
    (85) primary -> . LParen expression RParen
    (86) primary -> . arr_ref

    RBrace          shift and go to state 138
    If              shift and go to state 114
    While           shift and go to state 115
    For             shift and go to state 116
    Do              shift and go to state 118
    Return          shift and go to state 119
    LBrace          shift and go to state 106
    Break           shift and go to state 120
    Continue        shift and go to state 121
    Int             shift and go to state 6
    Semi            reduce using rule 4 (empty -> .)
    Identifier      shift and go to state 17
    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Integer         shift and go to state 38
    LParen          shift and go to state 36

    block_item                     shift and go to state 108
    statement                      shift and go to state 109
    declaration                    shift and go to state 110
    statement_matched              shift and go to state 111
    statement_unmatched            shift and go to state 112
    type                           shift and go to state 105
    expression                     shift and go to state 113
    opt_expression                 shift and go to state 117
    empty                          shift and go to state 122
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    arr_ref                        shift and go to state 21
    logical_or                     shift and go to state 22
    logical_and                    shift and go to state 23
    bit_or                         shift and go to state 24
    xor                            shift and go to state 25
    bit_and                        shift and go to state 26
    equality                       shift and go to state 27
    relational                     shift and go to state 28
    additive                       shift and go to state 29
    multiplicative                 shift and go to state 30
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 37

state 128

    (11) block_item -> declaration Semi .

    RBrace          reduce using rule 11 (block_item -> declaration Semi .)
    If              reduce using rule 11 (block_item -> declaration Semi .)
    While           reduce using rule 11 (block_item -> declaration Semi .)
    For             reduce using rule 11 (block_item -> declaration Semi .)
    Do              reduce using rule 11 (block_item -> declaration Semi .)
    Return          reduce using rule 11 (block_item -> declaration Semi .)
    LBrace          reduce using rule 11 (block_item -> declaration Semi .)
    Break           reduce using rule 11 (block_item -> declaration Semi .)
    Continue        reduce using rule 11 (block_item -> declaration Semi .)
    Int             reduce using rule 11 (block_item -> declaration Semi .)
    Identifier      reduce using rule 11 (block_item -> declaration Semi .)
    Minus           reduce using rule 11 (block_item -> declaration Semi .)
    BitNot          reduce using rule 11 (block_item -> declaration Semi .)
    Not             reduce using rule 11 (block_item -> declaration Semi .)
    Integer         reduce using rule 11 (block_item -> declaration Semi .)
    LParen          reduce using rule 11 (block_item -> declaration Semi .)
    Semi            reduce using rule 11 (block_item -> declaration Semi .)


state 129

    (14) statement_matched -> If LParen . expression RParen statement_matched Else statement_matched
    (15) statement_unmatched -> If LParen . expression RParen statement_matched Else statement_unmatched
    (16) statement_unmatched -> If LParen . expression RParen statement
    (44) expression -> . assignment
    (45) assignment -> . conditional
    (64) assignment -> . Identifier Assign expression
    (65) assignment -> . arr_ref Assign expression
    (46) conditional -> . logical_or
    (82) conditional -> . logical_or Question expression Colon conditional
    (63) arr_ref -> . Identifier arr_idx_list
    (47) logical_or -> . logical_and
    (66) logical_or -> . logical_or Or logical_and
    (48) logical_and -> . bit_or
    (67) logical_and -> . logical_and And bit_or
    (49) bit_or -> . xor
    (68) bit_or -> . bit_or BitOr xor
    (50) xor -> . bit_and
    (69) xor -> . xor Xor bit_and
    (51) bit_and -> . equality
    (70) bit_and -> . bit_and BitAnd equality
    (52) equality -> . relational
    (71) equality -> . equality NotEqual relational
    (72) equality -> . equality Equal relational
    (53) relational -> . additive
    (73) relational -> . relational Less additive
    (74) relational -> . relational Greater additive
    (75) relational -> . relational LessEqual additive
    (76) relational -> . relational GreaterEqual additive
    (54) additive -> . multiplicative
    (77) additive -> . additive Plus multiplicative
    (78) additive -> . additive Minus multiplicative
    (55) multiplicative -> . unary
    (79) multiplicative -> . multiplicative Mul unary
    (80) multiplicative -> . multiplicative Div unary
    (81) multiplicative -> . multiplicative Mod unary
    (56) unary -> . postfix
    (58) unary -> . Minus unary
    (59) unary -> . BitNot unary
    (60) unary -> . Not unary
    (37) postfix -> . Identifier LParen call_para RParen
    (57) postfix -> . primary
    (83) primary -> . Integer
    (84) primary -> . Identifier
    (85) primary -> . LParen expression RParen
    (86) primary -> . arr_ref

    Identifier      shift and go to state 17
    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Integer         shift and go to state 38
    LParen          shift and go to state 36

    expression                     shift and go to state 139
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    arr_ref                        shift and go to state 21
    logical_or                     shift and go to state 22
    logical_and                    shift and go to state 23
    bit_or                         shift and go to state 24
    xor                            shift and go to state 25
    bit_and                        shift and go to state 26
    equality                       shift and go to state 27
    relational                     shift and go to state 28
    additive                       shift and go to state 29
    multiplicative                 shift and go to state 30
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 37

state 130

    (17) statement_matched -> While LParen . expression RParen statement_matched
    (18) statement_unmatched -> While LParen . expression RParen statement_unmatched
    (44) expression -> . assignment
    (45) assignment -> . conditional
    (64) assignment -> . Identifier Assign expression
    (65) assignment -> . arr_ref Assign expression
    (46) conditional -> . logical_or
    (82) conditional -> . logical_or Question expression Colon conditional
    (63) arr_ref -> . Identifier arr_idx_list
    (47) logical_or -> . logical_and
    (66) logical_or -> . logical_or Or logical_and
    (48) logical_and -> . bit_or
    (67) logical_and -> . logical_and And bit_or
    (49) bit_or -> . xor
    (68) bit_or -> . bit_or BitOr xor
    (50) xor -> . bit_and
    (69) xor -> . xor Xor bit_and
    (51) bit_and -> . equality
    (70) bit_and -> . bit_and BitAnd equality
    (52) equality -> . relational
    (71) equality -> . equality NotEqual relational
    (72) equality -> . equality Equal relational
    (53) relational -> . additive
    (73) relational -> . relational Less additive
    (74) relational -> . relational Greater additive
    (75) relational -> . relational LessEqual additive
    (76) relational -> . relational GreaterEqual additive
    (54) additive -> . multiplicative
    (77) additive -> . additive Plus multiplicative
    (78) additive -> . additive Minus multiplicative
    (55) multiplicative -> . unary
    (79) multiplicative -> . multiplicative Mul unary
    (80) multiplicative -> . multiplicative Div unary
    (81) multiplicative -> . multiplicative Mod unary
    (56) unary -> . postfix
    (58) unary -> . Minus unary
    (59) unary -> . BitNot unary
    (60) unary -> . Not unary
    (37) postfix -> . Identifier LParen call_para RParen
    (57) postfix -> . primary
    (83) primary -> . Integer
    (84) primary -> . Identifier
    (85) primary -> . LParen expression RParen
    (86) primary -> . arr_ref

    Identifier      shift and go to state 17
    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Integer         shift and go to state 38
    LParen          shift and go to state 36

    expression                     shift and go to state 140
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    arr_ref                        shift and go to state 21
    logical_or                     shift and go to state 22
    logical_and                    shift and go to state 23
    bit_or                         shift and go to state 24
    xor                            shift and go to state 25
    bit_and                        shift and go to state 26
    equality                       shift and go to state 27
    relational                     shift and go to state 28
    additive                       shift and go to state 29
    multiplicative                 shift and go to state 30
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 37

state 131

    (19) statement_matched -> For LParen . opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
    (20) statement_matched -> For LParen . declaration Semi opt_expression Semi opt_expression RParen statement_matched
    (21) statement_unmatched -> For LParen . opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched
    (22) statement_unmatched -> For LParen . declaration Semi opt_expression Semi opt_expression RParen statement_unmatched
    (30) opt_expression -> . expression
    (31) opt_expression -> . empty
    (32) declaration -> . type Identifier
    (33) declaration -> . type Identifier Assign expression
    (36) declaration -> . type Identifier arr_dim_list
    (44) expression -> . assignment
    (4) empty -> .
    (6) type -> . Int
    (45) assignment -> . conditional
    (64) assignment -> . Identifier Assign expression
    (65) assignment -> . arr_ref Assign expression
    (46) conditional -> . logical_or
    (82) conditional -> . logical_or Question expression Colon conditional
    (63) arr_ref -> . Identifier arr_idx_list
    (47) logical_or -> . logical_and
    (66) logical_or -> . logical_or Or logical_and
    (48) logical_and -> . bit_or
    (67) logical_and -> . logical_and And bit_or
    (49) bit_or -> . xor
    (68) bit_or -> . bit_or BitOr xor
    (50) xor -> . bit_and
    (69) xor -> . xor Xor bit_and
    (51) bit_and -> . equality
    (70) bit_and -> . bit_and BitAnd equality
    (52) equality -> . relational
    (71) equality -> . equality NotEqual relational
    (72) equality -> . equality Equal relational
    (53) relational -> . additive
    (73) relational -> . relational Less additive
    (74) relational -> . relational Greater additive
    (75) relational -> . relational LessEqual additive
    (76) relational -> . relational GreaterEqual additive
    (54) additive -> . multiplicative
    (77) additive -> . additive Plus multiplicative
    (78) additive -> . additive Minus multiplicative
    (55) multiplicative -> . unary
    (79) multiplicative -> . multiplicative Mul unary
    (80) multiplicative -> . multiplicative Div unary
    (81) multiplicative -> . multiplicative Mod unary
    (56) unary -> . postfix
    (58) unary -> . Minus unary
    (59) unary -> . BitNot unary
    (60) unary -> . Not unary
    (37) postfix -> . Identifier LParen call_para RParen
    (57) postfix -> . primary
    (83) primary -> . Integer
    (84) primary -> . Identifier
    (85) primary -> . LParen expression RParen
    (86) primary -> . arr_ref

    Semi            reduce using rule 4 (empty -> .)
    Int             shift and go to state 6
    Identifier      shift and go to state 17
    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Integer         shift and go to state 38
    LParen          shift and go to state 36

    opt_expression                 shift and go to state 141
    declaration                    shift and go to state 142
    expression                     shift and go to state 113
    empty                          shift and go to state 122
    type                           shift and go to state 105
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    arr_ref                        shift and go to state 21
    logical_or                     shift and go to state 22
    logical_and                    shift and go to state 23
    bit_or                         shift and go to state 24
    xor                            shift and go to state 25
    bit_and                        shift and go to state 26
    equality                       shift and go to state 27
    relational                     shift and go to state 28
    additive                       shift and go to state 29
    multiplicative                 shift and go to state 30
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 37

state 132

    (26) statement_matched -> opt_expression Semi .

    RBrace          reduce using rule 26 (statement_matched -> opt_expression Semi .)
    If              reduce using rule 26 (statement_matched -> opt_expression Semi .)
    While           reduce using rule 26 (statement_matched -> opt_expression Semi .)
    For             reduce using rule 26 (statement_matched -> opt_expression Semi .)
    Do              reduce using rule 26 (statement_matched -> opt_expression Semi .)
    Return          reduce using rule 26 (statement_matched -> opt_expression Semi .)
    LBrace          reduce using rule 26 (statement_matched -> opt_expression Semi .)
    Break           reduce using rule 26 (statement_matched -> opt_expression Semi .)
    Continue        reduce using rule 26 (statement_matched -> opt_expression Semi .)
    Int             reduce using rule 26 (statement_matched -> opt_expression Semi .)
    Identifier      reduce using rule 26 (statement_matched -> opt_expression Semi .)
    Minus           reduce using rule 26 (statement_matched -> opt_expression Semi .)
    BitNot          reduce using rule 26 (statement_matched -> opt_expression Semi .)
    Not             reduce using rule 26 (statement_matched -> opt_expression Semi .)
    Integer         reduce using rule 26 (statement_matched -> opt_expression Semi .)
    LParen          reduce using rule 26 (statement_matched -> opt_expression Semi .)
    Semi            reduce using rule 26 (statement_matched -> opt_expression Semi .)
    Else            reduce using rule 26 (statement_matched -> opt_expression Semi .)


state 133

    (23) statement_matched -> Do statement_matched . While LParen expression RParen Semi

    While           shift and go to state 143


state 134

    (24) statement_unmatched -> Do statement_unmatched . While LParen expression RParen Semi

    While           shift and go to state 144


state 135

    (25) statement_matched -> Return expression . Semi

    Semi            shift and go to state 145


state 136

    (28) statement_matched -> Break Semi .

    RBrace          reduce using rule 28 (statement_matched -> Break Semi .)
    If              reduce using rule 28 (statement_matched -> Break Semi .)
    While           reduce using rule 28 (statement_matched -> Break Semi .)
    For             reduce using rule 28 (statement_matched -> Break Semi .)
    Do              reduce using rule 28 (statement_matched -> Break Semi .)
    Return          reduce using rule 28 (statement_matched -> Break Semi .)
    LBrace          reduce using rule 28 (statement_matched -> Break Semi .)
    Break           reduce using rule 28 (statement_matched -> Break Semi .)
    Continue        reduce using rule 28 (statement_matched -> Break Semi .)
    Int             reduce using rule 28 (statement_matched -> Break Semi .)
    Identifier      reduce using rule 28 (statement_matched -> Break Semi .)
    Minus           reduce using rule 28 (statement_matched -> Break Semi .)
    BitNot          reduce using rule 28 (statement_matched -> Break Semi .)
    Not             reduce using rule 28 (statement_matched -> Break Semi .)
    Integer         reduce using rule 28 (statement_matched -> Break Semi .)
    LParen          reduce using rule 28 (statement_matched -> Break Semi .)
    Semi            reduce using rule 28 (statement_matched -> Break Semi .)
    Else            reduce using rule 28 (statement_matched -> Break Semi .)


state 137

    (29) statement_matched -> Continue Semi .

    RBrace          reduce using rule 29 (statement_matched -> Continue Semi .)
    If              reduce using rule 29 (statement_matched -> Continue Semi .)
    While           reduce using rule 29 (statement_matched -> Continue Semi .)
    For             reduce using rule 29 (statement_matched -> Continue Semi .)
    Do              reduce using rule 29 (statement_matched -> Continue Semi .)
    Return          reduce using rule 29 (statement_matched -> Continue Semi .)
    LBrace          reduce using rule 29 (statement_matched -> Continue Semi .)
    Break           reduce using rule 29 (statement_matched -> Continue Semi .)
    Continue        reduce using rule 29 (statement_matched -> Continue Semi .)
    Int             reduce using rule 29 (statement_matched -> Continue Semi .)
    Identifier      reduce using rule 29 (statement_matched -> Continue Semi .)
    Minus           reduce using rule 29 (statement_matched -> Continue Semi .)
    BitNot          reduce using rule 29 (statement_matched -> Continue Semi .)
    Not             reduce using rule 29 (statement_matched -> Continue Semi .)
    Integer         reduce using rule 29 (statement_matched -> Continue Semi .)
    LParen          reduce using rule 29 (statement_matched -> Continue Semi .)
    Semi            reduce using rule 29 (statement_matched -> Continue Semi .)
    Else            reduce using rule 29 (statement_matched -> Continue Semi .)


state 138

    (27) statement_matched -> LBrace block RBrace .

    RBrace          reduce using rule 27 (statement_matched -> LBrace block RBrace .)
    If              reduce using rule 27 (statement_matched -> LBrace block RBrace .)
    While           reduce using rule 27 (statement_matched -> LBrace block RBrace .)
    For             reduce using rule 27 (statement_matched -> LBrace block RBrace .)
    Do              reduce using rule 27 (statement_matched -> LBrace block RBrace .)
    Return          reduce using rule 27 (statement_matched -> LBrace block RBrace .)
    LBrace          reduce using rule 27 (statement_matched -> LBrace block RBrace .)
    Break           reduce using rule 27 (statement_matched -> LBrace block RBrace .)
    Continue        reduce using rule 27 (statement_matched -> LBrace block RBrace .)
    Int             reduce using rule 27 (statement_matched -> LBrace block RBrace .)
    Identifier      reduce using rule 27 (statement_matched -> LBrace block RBrace .)
    Minus           reduce using rule 27 (statement_matched -> LBrace block RBrace .)
    BitNot          reduce using rule 27 (statement_matched -> LBrace block RBrace .)
    Not             reduce using rule 27 (statement_matched -> LBrace block RBrace .)
    Integer         reduce using rule 27 (statement_matched -> LBrace block RBrace .)
    LParen          reduce using rule 27 (statement_matched -> LBrace block RBrace .)
    Semi            reduce using rule 27 (statement_matched -> LBrace block RBrace .)
    Else            reduce using rule 27 (statement_matched -> LBrace block RBrace .)


state 139

    (14) statement_matched -> If LParen expression . RParen statement_matched Else statement_matched
    (15) statement_unmatched -> If LParen expression . RParen statement_matched Else statement_unmatched
    (16) statement_unmatched -> If LParen expression . RParen statement

    RParen          shift and go to state 146


state 140

    (17) statement_matched -> While LParen expression . RParen statement_matched
    (18) statement_unmatched -> While LParen expression . RParen statement_unmatched

    RParen          shift and go to state 147


state 141

    (19) statement_matched -> For LParen opt_expression . Semi opt_expression Semi opt_expression RParen statement_matched
    (21) statement_unmatched -> For LParen opt_expression . Semi opt_expression Semi opt_expression RParen statement_unmatched

    Semi            shift and go to state 148


state 142

    (20) statement_matched -> For LParen declaration . Semi opt_expression Semi opt_expression RParen statement_matched
    (22) statement_unmatched -> For LParen declaration . Semi opt_expression Semi opt_expression RParen statement_unmatched

    Semi            shift and go to state 149


state 143

    (23) statement_matched -> Do statement_matched While . LParen expression RParen Semi

    LParen          shift and go to state 150


state 144

    (24) statement_unmatched -> Do statement_unmatched While . LParen expression RParen Semi

    LParen          shift and go to state 151


state 145

    (25) statement_matched -> Return expression Semi .

    RBrace          reduce using rule 25 (statement_matched -> Return expression Semi .)
    If              reduce using rule 25 (statement_matched -> Return expression Semi .)
    While           reduce using rule 25 (statement_matched -> Return expression Semi .)
    For             reduce using rule 25 (statement_matched -> Return expression Semi .)
    Do              reduce using rule 25 (statement_matched -> Return expression Semi .)
    Return          reduce using rule 25 (statement_matched -> Return expression Semi .)
    LBrace          reduce using rule 25 (statement_matched -> Return expression Semi .)
    Break           reduce using rule 25 (statement_matched -> Return expression Semi .)
    Continue        reduce using rule 25 (statement_matched -> Return expression Semi .)
    Int             reduce using rule 25 (statement_matched -> Return expression Semi .)
    Identifier      reduce using rule 25 (statement_matched -> Return expression Semi .)
    Minus           reduce using rule 25 (statement_matched -> Return expression Semi .)
    BitNot          reduce using rule 25 (statement_matched -> Return expression Semi .)
    Not             reduce using rule 25 (statement_matched -> Return expression Semi .)
    Integer         reduce using rule 25 (statement_matched -> Return expression Semi .)
    LParen          reduce using rule 25 (statement_matched -> Return expression Semi .)
    Semi            reduce using rule 25 (statement_matched -> Return expression Semi .)
    Else            reduce using rule 25 (statement_matched -> Return expression Semi .)


state 146

    (14) statement_matched -> If LParen expression RParen . statement_matched Else statement_matched
    (15) statement_unmatched -> If LParen expression RParen . statement_matched Else statement_unmatched
    (16) statement_unmatched -> If LParen expression RParen . statement
    (14) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (17) statement_matched -> . While LParen expression RParen statement_matched
    (19) statement_matched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
    (20) statement_matched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched
    (23) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (25) statement_matched -> . Return expression Semi
    (26) statement_matched -> . opt_expression Semi
    (27) statement_matched -> . LBrace block RBrace
    (28) statement_matched -> . Break Semi
    (29) statement_matched -> . Continue Semi
    (12) statement -> . statement_matched
    (13) statement -> . statement_unmatched
    (30) opt_expression -> . expression
    (31) opt_expression -> . empty
    (15) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (16) statement_unmatched -> . If LParen expression RParen statement
    (18) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (21) statement_unmatched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched
    (22) statement_unmatched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched
    (24) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (44) expression -> . assignment
    (4) empty -> .
    (45) assignment -> . conditional
    (64) assignment -> . Identifier Assign expression
    (65) assignment -> . arr_ref Assign expression
    (46) conditional -> . logical_or
    (82) conditional -> . logical_or Question expression Colon conditional
    (63) arr_ref -> . Identifier arr_idx_list
    (47) logical_or -> . logical_and
    (66) logical_or -> . logical_or Or logical_and
    (48) logical_and -> . bit_or
    (67) logical_and -> . logical_and And bit_or
    (49) bit_or -> . xor
    (68) bit_or -> . bit_or BitOr xor
    (50) xor -> . bit_and
    (69) xor -> . xor Xor bit_and
    (51) bit_and -> . equality
    (70) bit_and -> . bit_and BitAnd equality
    (52) equality -> . relational
    (71) equality -> . equality NotEqual relational
    (72) equality -> . equality Equal relational
    (53) relational -> . additive
    (73) relational -> . relational Less additive
    (74) relational -> . relational Greater additive
    (75) relational -> . relational LessEqual additive
    (76) relational -> . relational GreaterEqual additive
    (54) additive -> . multiplicative
    (77) additive -> . additive Plus multiplicative
    (78) additive -> . additive Minus multiplicative
    (55) multiplicative -> . unary
    (79) multiplicative -> . multiplicative Mul unary
    (80) multiplicative -> . multiplicative Div unary
    (81) multiplicative -> . multiplicative Mod unary
    (56) unary -> . postfix
    (58) unary -> . Minus unary
    (59) unary -> . BitNot unary
    (60) unary -> . Not unary
    (37) postfix -> . Identifier LParen call_para RParen
    (57) postfix -> . primary
    (83) primary -> . Integer
    (84) primary -> . Identifier
    (85) primary -> . LParen expression RParen
    (86) primary -> . arr_ref

    If              shift and go to state 114
    While           shift and go to state 115
    For             shift and go to state 116
    Do              shift and go to state 118
    Return          shift and go to state 119
    LBrace          shift and go to state 106
    Break           shift and go to state 120
    Continue        shift and go to state 121
    Semi            reduce using rule 4 (empty -> .)
    Identifier      shift and go to state 17
    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Integer         shift and go to state 38
    LParen          shift and go to state 36

    expression                     shift and go to state 113
    statement_matched              shift and go to state 152
    statement_unmatched            shift and go to state 112
    statement                      shift and go to state 153
    opt_expression                 shift and go to state 117
    empty                          shift and go to state 122
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    arr_ref                        shift and go to state 21
    logical_or                     shift and go to state 22
    logical_and                    shift and go to state 23
    bit_or                         shift and go to state 24
    xor                            shift and go to state 25
    bit_and                        shift and go to state 26
    equality                       shift and go to state 27
    relational                     shift and go to state 28
    additive                       shift and go to state 29
    multiplicative                 shift and go to state 30
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 37

state 147

    (17) statement_matched -> While LParen expression RParen . statement_matched
    (18) statement_unmatched -> While LParen expression RParen . statement_unmatched
    (14) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (17) statement_matched -> . While LParen expression RParen statement_matched
    (19) statement_matched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
    (20) statement_matched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched
    (23) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (25) statement_matched -> . Return expression Semi
    (26) statement_matched -> . opt_expression Semi
    (27) statement_matched -> . LBrace block RBrace
    (28) statement_matched -> . Break Semi
    (29) statement_matched -> . Continue Semi
    (15) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (16) statement_unmatched -> . If LParen expression RParen statement
    (18) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (21) statement_unmatched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched
    (22) statement_unmatched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched
    (24) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (30) opt_expression -> . expression
    (31) opt_expression -> . empty
    (44) expression -> . assignment
    (4) empty -> .
    (45) assignment -> . conditional
    (64) assignment -> . Identifier Assign expression
    (65) assignment -> . arr_ref Assign expression
    (46) conditional -> . logical_or
    (82) conditional -> . logical_or Question expression Colon conditional
    (63) arr_ref -> . Identifier arr_idx_list
    (47) logical_or -> . logical_and
    (66) logical_or -> . logical_or Or logical_and
    (48) logical_and -> . bit_or
    (67) logical_and -> . logical_and And bit_or
    (49) bit_or -> . xor
    (68) bit_or -> . bit_or BitOr xor
    (50) xor -> . bit_and
    (69) xor -> . xor Xor bit_and
    (51) bit_and -> . equality
    (70) bit_and -> . bit_and BitAnd equality
    (52) equality -> . relational
    (71) equality -> . equality NotEqual relational
    (72) equality -> . equality Equal relational
    (53) relational -> . additive
    (73) relational -> . relational Less additive
    (74) relational -> . relational Greater additive
    (75) relational -> . relational LessEqual additive
    (76) relational -> . relational GreaterEqual additive
    (54) additive -> . multiplicative
    (77) additive -> . additive Plus multiplicative
    (78) additive -> . additive Minus multiplicative
    (55) multiplicative -> . unary
    (79) multiplicative -> . multiplicative Mul unary
    (80) multiplicative -> . multiplicative Div unary
    (81) multiplicative -> . multiplicative Mod unary
    (56) unary -> . postfix
    (58) unary -> . Minus unary
    (59) unary -> . BitNot unary
    (60) unary -> . Not unary
    (37) postfix -> . Identifier LParen call_para RParen
    (57) postfix -> . primary
    (83) primary -> . Integer
    (84) primary -> . Identifier
    (85) primary -> . LParen expression RParen
    (86) primary -> . arr_ref

    If              shift and go to state 114
    While           shift and go to state 115
    For             shift and go to state 116
    Do              shift and go to state 118
    Return          shift and go to state 119
    LBrace          shift and go to state 106
    Break           shift and go to state 120
    Continue        shift and go to state 121
    Semi            reduce using rule 4 (empty -> .)
    Identifier      shift and go to state 17
    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Integer         shift and go to state 38
    LParen          shift and go to state 36

    expression                     shift and go to state 113
    statement_matched              shift and go to state 154
    statement_unmatched            shift and go to state 155
    opt_expression                 shift and go to state 117
    empty                          shift and go to state 122
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    arr_ref                        shift and go to state 21
    logical_or                     shift and go to state 22
    logical_and                    shift and go to state 23
    bit_or                         shift and go to state 24
    xor                            shift and go to state 25
    bit_and                        shift and go to state 26
    equality                       shift and go to state 27
    relational                     shift and go to state 28
    additive                       shift and go to state 29
    multiplicative                 shift and go to state 30
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 37

state 148

    (19) statement_matched -> For LParen opt_expression Semi . opt_expression Semi opt_expression RParen statement_matched
    (21) statement_unmatched -> For LParen opt_expression Semi . opt_expression Semi opt_expression RParen statement_unmatched
    (30) opt_expression -> . expression
    (31) opt_expression -> . empty
    (44) expression -> . assignment
    (4) empty -> .
    (45) assignment -> . conditional
    (64) assignment -> . Identifier Assign expression
    (65) assignment -> . arr_ref Assign expression
    (46) conditional -> . logical_or
    (82) conditional -> . logical_or Question expression Colon conditional
    (63) arr_ref -> . Identifier arr_idx_list
    (47) logical_or -> . logical_and
    (66) logical_or -> . logical_or Or logical_and
    (48) logical_and -> . bit_or
    (67) logical_and -> . logical_and And bit_or
    (49) bit_or -> . xor
    (68) bit_or -> . bit_or BitOr xor
    (50) xor -> . bit_and
    (69) xor -> . xor Xor bit_and
    (51) bit_and -> . equality
    (70) bit_and -> . bit_and BitAnd equality
    (52) equality -> . relational
    (71) equality -> . equality NotEqual relational
    (72) equality -> . equality Equal relational
    (53) relational -> . additive
    (73) relational -> . relational Less additive
    (74) relational -> . relational Greater additive
    (75) relational -> . relational LessEqual additive
    (76) relational -> . relational GreaterEqual additive
    (54) additive -> . multiplicative
    (77) additive -> . additive Plus multiplicative
    (78) additive -> . additive Minus multiplicative
    (55) multiplicative -> . unary
    (79) multiplicative -> . multiplicative Mul unary
    (80) multiplicative -> . multiplicative Div unary
    (81) multiplicative -> . multiplicative Mod unary
    (56) unary -> . postfix
    (58) unary -> . Minus unary
    (59) unary -> . BitNot unary
    (60) unary -> . Not unary
    (37) postfix -> . Identifier LParen call_para RParen
    (57) postfix -> . primary
    (83) primary -> . Integer
    (84) primary -> . Identifier
    (85) primary -> . LParen expression RParen
    (86) primary -> . arr_ref

    Semi            reduce using rule 4 (empty -> .)
    Identifier      shift and go to state 17
    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Integer         shift and go to state 38
    LParen          shift and go to state 36

    opt_expression                 shift and go to state 156
    expression                     shift and go to state 113
    empty                          shift and go to state 122
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    arr_ref                        shift and go to state 21
    logical_or                     shift and go to state 22
    logical_and                    shift and go to state 23
    bit_or                         shift and go to state 24
    xor                            shift and go to state 25
    bit_and                        shift and go to state 26
    equality                       shift and go to state 27
    relational                     shift and go to state 28
    additive                       shift and go to state 29
    multiplicative                 shift and go to state 30
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 37

state 149

    (20) statement_matched -> For LParen declaration Semi . opt_expression Semi opt_expression RParen statement_matched
    (22) statement_unmatched -> For LParen declaration Semi . opt_expression Semi opt_expression RParen statement_unmatched
    (30) opt_expression -> . expression
    (31) opt_expression -> . empty
    (44) expression -> . assignment
    (4) empty -> .
    (45) assignment -> . conditional
    (64) assignment -> . Identifier Assign expression
    (65) assignment -> . arr_ref Assign expression
    (46) conditional -> . logical_or
    (82) conditional -> . logical_or Question expression Colon conditional
    (63) arr_ref -> . Identifier arr_idx_list
    (47) logical_or -> . logical_and
    (66) logical_or -> . logical_or Or logical_and
    (48) logical_and -> . bit_or
    (67) logical_and -> . logical_and And bit_or
    (49) bit_or -> . xor
    (68) bit_or -> . bit_or BitOr xor
    (50) xor -> . bit_and
    (69) xor -> . xor Xor bit_and
    (51) bit_and -> . equality
    (70) bit_and -> . bit_and BitAnd equality
    (52) equality -> . relational
    (71) equality -> . equality NotEqual relational
    (72) equality -> . equality Equal relational
    (53) relational -> . additive
    (73) relational -> . relational Less additive
    (74) relational -> . relational Greater additive
    (75) relational -> . relational LessEqual additive
    (76) relational -> . relational GreaterEqual additive
    (54) additive -> . multiplicative
    (77) additive -> . additive Plus multiplicative
    (78) additive -> . additive Minus multiplicative
    (55) multiplicative -> . unary
    (79) multiplicative -> . multiplicative Mul unary
    (80) multiplicative -> . multiplicative Div unary
    (81) multiplicative -> . multiplicative Mod unary
    (56) unary -> . postfix
    (58) unary -> . Minus unary
    (59) unary -> . BitNot unary
    (60) unary -> . Not unary
    (37) postfix -> . Identifier LParen call_para RParen
    (57) postfix -> . primary
    (83) primary -> . Integer
    (84) primary -> . Identifier
    (85) primary -> . LParen expression RParen
    (86) primary -> . arr_ref

    Semi            reduce using rule 4 (empty -> .)
    Identifier      shift and go to state 17
    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Integer         shift and go to state 38
    LParen          shift and go to state 36

    opt_expression                 shift and go to state 157
    expression                     shift and go to state 113
    empty                          shift and go to state 122
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    arr_ref                        shift and go to state 21
    logical_or                     shift and go to state 22
    logical_and                    shift and go to state 23
    bit_or                         shift and go to state 24
    xor                            shift and go to state 25
    bit_and                        shift and go to state 26
    equality                       shift and go to state 27
    relational                     shift and go to state 28
    additive                       shift and go to state 29
    multiplicative                 shift and go to state 30
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 37

state 150

    (23) statement_matched -> Do statement_matched While LParen . expression RParen Semi
    (44) expression -> . assignment
    (45) assignment -> . conditional
    (64) assignment -> . Identifier Assign expression
    (65) assignment -> . arr_ref Assign expression
    (46) conditional -> . logical_or
    (82) conditional -> . logical_or Question expression Colon conditional
    (63) arr_ref -> . Identifier arr_idx_list
    (47) logical_or -> . logical_and
    (66) logical_or -> . logical_or Or logical_and
    (48) logical_and -> . bit_or
    (67) logical_and -> . logical_and And bit_or
    (49) bit_or -> . xor
    (68) bit_or -> . bit_or BitOr xor
    (50) xor -> . bit_and
    (69) xor -> . xor Xor bit_and
    (51) bit_and -> . equality
    (70) bit_and -> . bit_and BitAnd equality
    (52) equality -> . relational
    (71) equality -> . equality NotEqual relational
    (72) equality -> . equality Equal relational
    (53) relational -> . additive
    (73) relational -> . relational Less additive
    (74) relational -> . relational Greater additive
    (75) relational -> . relational LessEqual additive
    (76) relational -> . relational GreaterEqual additive
    (54) additive -> . multiplicative
    (77) additive -> . additive Plus multiplicative
    (78) additive -> . additive Minus multiplicative
    (55) multiplicative -> . unary
    (79) multiplicative -> . multiplicative Mul unary
    (80) multiplicative -> . multiplicative Div unary
    (81) multiplicative -> . multiplicative Mod unary
    (56) unary -> . postfix
    (58) unary -> . Minus unary
    (59) unary -> . BitNot unary
    (60) unary -> . Not unary
    (37) postfix -> . Identifier LParen call_para RParen
    (57) postfix -> . primary
    (83) primary -> . Integer
    (84) primary -> . Identifier
    (85) primary -> . LParen expression RParen
    (86) primary -> . arr_ref

    Identifier      shift and go to state 17
    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Integer         shift and go to state 38
    LParen          shift and go to state 36

    expression                     shift and go to state 158
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    arr_ref                        shift and go to state 21
    logical_or                     shift and go to state 22
    logical_and                    shift and go to state 23
    bit_or                         shift and go to state 24
    xor                            shift and go to state 25
    bit_and                        shift and go to state 26
    equality                       shift and go to state 27
    relational                     shift and go to state 28
    additive                       shift and go to state 29
    multiplicative                 shift and go to state 30
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 37

state 151

    (24) statement_unmatched -> Do statement_unmatched While LParen . expression RParen Semi
    (44) expression -> . assignment
    (45) assignment -> . conditional
    (64) assignment -> . Identifier Assign expression
    (65) assignment -> . arr_ref Assign expression
    (46) conditional -> . logical_or
    (82) conditional -> . logical_or Question expression Colon conditional
    (63) arr_ref -> . Identifier arr_idx_list
    (47) logical_or -> . logical_and
    (66) logical_or -> . logical_or Or logical_and
    (48) logical_and -> . bit_or
    (67) logical_and -> . logical_and And bit_or
    (49) bit_or -> . xor
    (68) bit_or -> . bit_or BitOr xor
    (50) xor -> . bit_and
    (69) xor -> . xor Xor bit_and
    (51) bit_and -> . equality
    (70) bit_and -> . bit_and BitAnd equality
    (52) equality -> . relational
    (71) equality -> . equality NotEqual relational
    (72) equality -> . equality Equal relational
    (53) relational -> . additive
    (73) relational -> . relational Less additive
    (74) relational -> . relational Greater additive
    (75) relational -> . relational LessEqual additive
    (76) relational -> . relational GreaterEqual additive
    (54) additive -> . multiplicative
    (77) additive -> . additive Plus multiplicative
    (78) additive -> . additive Minus multiplicative
    (55) multiplicative -> . unary
    (79) multiplicative -> . multiplicative Mul unary
    (80) multiplicative -> . multiplicative Div unary
    (81) multiplicative -> . multiplicative Mod unary
    (56) unary -> . postfix
    (58) unary -> . Minus unary
    (59) unary -> . BitNot unary
    (60) unary -> . Not unary
    (37) postfix -> . Identifier LParen call_para RParen
    (57) postfix -> . primary
    (83) primary -> . Integer
    (84) primary -> . Identifier
    (85) primary -> . LParen expression RParen
    (86) primary -> . arr_ref

    Identifier      shift and go to state 17
    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Integer         shift and go to state 38
    LParen          shift and go to state 36

    expression                     shift and go to state 159
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    arr_ref                        shift and go to state 21
    logical_or                     shift and go to state 22
    logical_and                    shift and go to state 23
    bit_or                         shift and go to state 24
    xor                            shift and go to state 25
    bit_and                        shift and go to state 26
    equality                       shift and go to state 27
    relational                     shift and go to state 28
    additive                       shift and go to state 29
    multiplicative                 shift and go to state 30
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 37

state 152

    (14) statement_matched -> If LParen expression RParen statement_matched . Else statement_matched
    (15) statement_unmatched -> If LParen expression RParen statement_matched . Else statement_unmatched
    (12) statement -> statement_matched .

    Else            shift and go to state 160
    RBrace          reduce using rule 12 (statement -> statement_matched .)
    If              reduce using rule 12 (statement -> statement_matched .)
    While           reduce using rule 12 (statement -> statement_matched .)
    For             reduce using rule 12 (statement -> statement_matched .)
    Do              reduce using rule 12 (statement -> statement_matched .)
    Return          reduce using rule 12 (statement -> statement_matched .)
    LBrace          reduce using rule 12 (statement -> statement_matched .)
    Break           reduce using rule 12 (statement -> statement_matched .)
    Continue        reduce using rule 12 (statement -> statement_matched .)
    Int             reduce using rule 12 (statement -> statement_matched .)
    Identifier      reduce using rule 12 (statement -> statement_matched .)
    Minus           reduce using rule 12 (statement -> statement_matched .)
    BitNot          reduce using rule 12 (statement -> statement_matched .)
    Not             reduce using rule 12 (statement -> statement_matched .)
    Integer         reduce using rule 12 (statement -> statement_matched .)
    LParen          reduce using rule 12 (statement -> statement_matched .)
    Semi            reduce using rule 12 (statement -> statement_matched .)


state 153

    (16) statement_unmatched -> If LParen expression RParen statement .

    RBrace          reduce using rule 16 (statement_unmatched -> If LParen expression RParen statement .)
    If              reduce using rule 16 (statement_unmatched -> If LParen expression RParen statement .)
    While           reduce using rule 16 (statement_unmatched -> If LParen expression RParen statement .)
    For             reduce using rule 16 (statement_unmatched -> If LParen expression RParen statement .)
    Do              reduce using rule 16 (statement_unmatched -> If LParen expression RParen statement .)
    Return          reduce using rule 16 (statement_unmatched -> If LParen expression RParen statement .)
    LBrace          reduce using rule 16 (statement_unmatched -> If LParen expression RParen statement .)
    Break           reduce using rule 16 (statement_unmatched -> If LParen expression RParen statement .)
    Continue        reduce using rule 16 (statement_unmatched -> If LParen expression RParen statement .)
    Int             reduce using rule 16 (statement_unmatched -> If LParen expression RParen statement .)
    Identifier      reduce using rule 16 (statement_unmatched -> If LParen expression RParen statement .)
    Minus           reduce using rule 16 (statement_unmatched -> If LParen expression RParen statement .)
    BitNot          reduce using rule 16 (statement_unmatched -> If LParen expression RParen statement .)
    Not             reduce using rule 16 (statement_unmatched -> If LParen expression RParen statement .)
    Integer         reduce using rule 16 (statement_unmatched -> If LParen expression RParen statement .)
    LParen          reduce using rule 16 (statement_unmatched -> If LParen expression RParen statement .)
    Semi            reduce using rule 16 (statement_unmatched -> If LParen expression RParen statement .)


state 154

    (17) statement_matched -> While LParen expression RParen statement_matched .

    RBrace          reduce using rule 17 (statement_matched -> While LParen expression RParen statement_matched .)
    If              reduce using rule 17 (statement_matched -> While LParen expression RParen statement_matched .)
    While           reduce using rule 17 (statement_matched -> While LParen expression RParen statement_matched .)
    For             reduce using rule 17 (statement_matched -> While LParen expression RParen statement_matched .)
    Do              reduce using rule 17 (statement_matched -> While LParen expression RParen statement_matched .)
    Return          reduce using rule 17 (statement_matched -> While LParen expression RParen statement_matched .)
    LBrace          reduce using rule 17 (statement_matched -> While LParen expression RParen statement_matched .)
    Break           reduce using rule 17 (statement_matched -> While LParen expression RParen statement_matched .)
    Continue        reduce using rule 17 (statement_matched -> While LParen expression RParen statement_matched .)
    Int             reduce using rule 17 (statement_matched -> While LParen expression RParen statement_matched .)
    Identifier      reduce using rule 17 (statement_matched -> While LParen expression RParen statement_matched .)
    Minus           reduce using rule 17 (statement_matched -> While LParen expression RParen statement_matched .)
    BitNot          reduce using rule 17 (statement_matched -> While LParen expression RParen statement_matched .)
    Not             reduce using rule 17 (statement_matched -> While LParen expression RParen statement_matched .)
    Integer         reduce using rule 17 (statement_matched -> While LParen expression RParen statement_matched .)
    LParen          reduce using rule 17 (statement_matched -> While LParen expression RParen statement_matched .)
    Semi            reduce using rule 17 (statement_matched -> While LParen expression RParen statement_matched .)
    Else            reduce using rule 17 (statement_matched -> While LParen expression RParen statement_matched .)


state 155

    (18) statement_unmatched -> While LParen expression RParen statement_unmatched .

    RBrace          reduce using rule 18 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    If              reduce using rule 18 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    While           reduce using rule 18 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    For             reduce using rule 18 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Do              reduce using rule 18 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Return          reduce using rule 18 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    LBrace          reduce using rule 18 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Break           reduce using rule 18 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Continue        reduce using rule 18 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Int             reduce using rule 18 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Identifier      reduce using rule 18 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Minus           reduce using rule 18 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    BitNot          reduce using rule 18 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Not             reduce using rule 18 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Integer         reduce using rule 18 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    LParen          reduce using rule 18 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Semi            reduce using rule 18 (statement_unmatched -> While LParen expression RParen statement_unmatched .)


state 156

    (19) statement_matched -> For LParen opt_expression Semi opt_expression . Semi opt_expression RParen statement_matched
    (21) statement_unmatched -> For LParen opt_expression Semi opt_expression . Semi opt_expression RParen statement_unmatched

    Semi            shift and go to state 161


state 157

    (20) statement_matched -> For LParen declaration Semi opt_expression . Semi opt_expression RParen statement_matched
    (22) statement_unmatched -> For LParen declaration Semi opt_expression . Semi opt_expression RParen statement_unmatched

    Semi            shift and go to state 162


state 158

    (23) statement_matched -> Do statement_matched While LParen expression . RParen Semi

    RParen          shift and go to state 163


state 159

    (24) statement_unmatched -> Do statement_unmatched While LParen expression . RParen Semi

    RParen          shift and go to state 164


state 160

    (14) statement_matched -> If LParen expression RParen statement_matched Else . statement_matched
    (15) statement_unmatched -> If LParen expression RParen statement_matched Else . statement_unmatched
    (14) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (17) statement_matched -> . While LParen expression RParen statement_matched
    (19) statement_matched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
    (20) statement_matched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched
    (23) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (25) statement_matched -> . Return expression Semi
    (26) statement_matched -> . opt_expression Semi
    (27) statement_matched -> . LBrace block RBrace
    (28) statement_matched -> . Break Semi
    (29) statement_matched -> . Continue Semi
    (15) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (16) statement_unmatched -> . If LParen expression RParen statement
    (18) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (21) statement_unmatched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched
    (22) statement_unmatched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched
    (24) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (30) opt_expression -> . expression
    (31) opt_expression -> . empty
    (44) expression -> . assignment
    (4) empty -> .
    (45) assignment -> . conditional
    (64) assignment -> . Identifier Assign expression
    (65) assignment -> . arr_ref Assign expression
    (46) conditional -> . logical_or
    (82) conditional -> . logical_or Question expression Colon conditional
    (63) arr_ref -> . Identifier arr_idx_list
    (47) logical_or -> . logical_and
    (66) logical_or -> . logical_or Or logical_and
    (48) logical_and -> . bit_or
    (67) logical_and -> . logical_and And bit_or
    (49) bit_or -> . xor
    (68) bit_or -> . bit_or BitOr xor
    (50) xor -> . bit_and
    (69) xor -> . xor Xor bit_and
    (51) bit_and -> . equality
    (70) bit_and -> . bit_and BitAnd equality
    (52) equality -> . relational
    (71) equality -> . equality NotEqual relational
    (72) equality -> . equality Equal relational
    (53) relational -> . additive
    (73) relational -> . relational Less additive
    (74) relational -> . relational Greater additive
    (75) relational -> . relational LessEqual additive
    (76) relational -> . relational GreaterEqual additive
    (54) additive -> . multiplicative
    (77) additive -> . additive Plus multiplicative
    (78) additive -> . additive Minus multiplicative
    (55) multiplicative -> . unary
    (79) multiplicative -> . multiplicative Mul unary
    (80) multiplicative -> . multiplicative Div unary
    (81) multiplicative -> . multiplicative Mod unary
    (56) unary -> . postfix
    (58) unary -> . Minus unary
    (59) unary -> . BitNot unary
    (60) unary -> . Not unary
    (37) postfix -> . Identifier LParen call_para RParen
    (57) postfix -> . primary
    (83) primary -> . Integer
    (84) primary -> . Identifier
    (85) primary -> . LParen expression RParen
    (86) primary -> . arr_ref

    If              shift and go to state 114
    While           shift and go to state 115
    For             shift and go to state 116
    Do              shift and go to state 118
    Return          shift and go to state 119
    LBrace          shift and go to state 106
    Break           shift and go to state 120
    Continue        shift and go to state 121
    Semi            reduce using rule 4 (empty -> .)
    Identifier      shift and go to state 17
    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Integer         shift and go to state 38
    LParen          shift and go to state 36

    expression                     shift and go to state 113
    statement_matched              shift and go to state 165
    statement_unmatched            shift and go to state 166
    opt_expression                 shift and go to state 117
    empty                          shift and go to state 122
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    arr_ref                        shift and go to state 21
    logical_or                     shift and go to state 22
    logical_and                    shift and go to state 23
    bit_or                         shift and go to state 24
    xor                            shift and go to state 25
    bit_and                        shift and go to state 26
    equality                       shift and go to state 27
    relational                     shift and go to state 28
    additive                       shift and go to state 29
    multiplicative                 shift and go to state 30
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 37

state 161

    (19) statement_matched -> For LParen opt_expression Semi opt_expression Semi . opt_expression RParen statement_matched
    (21) statement_unmatched -> For LParen opt_expression Semi opt_expression Semi . opt_expression RParen statement_unmatched
    (30) opt_expression -> . expression
    (31) opt_expression -> . empty
    (44) expression -> . assignment
    (4) empty -> .
    (45) assignment -> . conditional
    (64) assignment -> . Identifier Assign expression
    (65) assignment -> . arr_ref Assign expression
    (46) conditional -> . logical_or
    (82) conditional -> . logical_or Question expression Colon conditional
    (63) arr_ref -> . Identifier arr_idx_list
    (47) logical_or -> . logical_and
    (66) logical_or -> . logical_or Or logical_and
    (48) logical_and -> . bit_or
    (67) logical_and -> . logical_and And bit_or
    (49) bit_or -> . xor
    (68) bit_or -> . bit_or BitOr xor
    (50) xor -> . bit_and
    (69) xor -> . xor Xor bit_and
    (51) bit_and -> . equality
    (70) bit_and -> . bit_and BitAnd equality
    (52) equality -> . relational
    (71) equality -> . equality NotEqual relational
    (72) equality -> . equality Equal relational
    (53) relational -> . additive
    (73) relational -> . relational Less additive
    (74) relational -> . relational Greater additive
    (75) relational -> . relational LessEqual additive
    (76) relational -> . relational GreaterEqual additive
    (54) additive -> . multiplicative
    (77) additive -> . additive Plus multiplicative
    (78) additive -> . additive Minus multiplicative
    (55) multiplicative -> . unary
    (79) multiplicative -> . multiplicative Mul unary
    (80) multiplicative -> . multiplicative Div unary
    (81) multiplicative -> . multiplicative Mod unary
    (56) unary -> . postfix
    (58) unary -> . Minus unary
    (59) unary -> . BitNot unary
    (60) unary -> . Not unary
    (37) postfix -> . Identifier LParen call_para RParen
    (57) postfix -> . primary
    (83) primary -> . Integer
    (84) primary -> . Identifier
    (85) primary -> . LParen expression RParen
    (86) primary -> . arr_ref

    RParen          reduce using rule 4 (empty -> .)
    Identifier      shift and go to state 17
    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Integer         shift and go to state 38
    LParen          shift and go to state 36

    opt_expression                 shift and go to state 167
    expression                     shift and go to state 113
    empty                          shift and go to state 122
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    arr_ref                        shift and go to state 21
    logical_or                     shift and go to state 22
    logical_and                    shift and go to state 23
    bit_or                         shift and go to state 24
    xor                            shift and go to state 25
    bit_and                        shift and go to state 26
    equality                       shift and go to state 27
    relational                     shift and go to state 28
    additive                       shift and go to state 29
    multiplicative                 shift and go to state 30
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 37

state 162

    (20) statement_matched -> For LParen declaration Semi opt_expression Semi . opt_expression RParen statement_matched
    (22) statement_unmatched -> For LParen declaration Semi opt_expression Semi . opt_expression RParen statement_unmatched
    (30) opt_expression -> . expression
    (31) opt_expression -> . empty
    (44) expression -> . assignment
    (4) empty -> .
    (45) assignment -> . conditional
    (64) assignment -> . Identifier Assign expression
    (65) assignment -> . arr_ref Assign expression
    (46) conditional -> . logical_or
    (82) conditional -> . logical_or Question expression Colon conditional
    (63) arr_ref -> . Identifier arr_idx_list
    (47) logical_or -> . logical_and
    (66) logical_or -> . logical_or Or logical_and
    (48) logical_and -> . bit_or
    (67) logical_and -> . logical_and And bit_or
    (49) bit_or -> . xor
    (68) bit_or -> . bit_or BitOr xor
    (50) xor -> . bit_and
    (69) xor -> . xor Xor bit_and
    (51) bit_and -> . equality
    (70) bit_and -> . bit_and BitAnd equality
    (52) equality -> . relational
    (71) equality -> . equality NotEqual relational
    (72) equality -> . equality Equal relational
    (53) relational -> . additive
    (73) relational -> . relational Less additive
    (74) relational -> . relational Greater additive
    (75) relational -> . relational LessEqual additive
    (76) relational -> . relational GreaterEqual additive
    (54) additive -> . multiplicative
    (77) additive -> . additive Plus multiplicative
    (78) additive -> . additive Minus multiplicative
    (55) multiplicative -> . unary
    (79) multiplicative -> . multiplicative Mul unary
    (80) multiplicative -> . multiplicative Div unary
    (81) multiplicative -> . multiplicative Mod unary
    (56) unary -> . postfix
    (58) unary -> . Minus unary
    (59) unary -> . BitNot unary
    (60) unary -> . Not unary
    (37) postfix -> . Identifier LParen call_para RParen
    (57) postfix -> . primary
    (83) primary -> . Integer
    (84) primary -> . Identifier
    (85) primary -> . LParen expression RParen
    (86) primary -> . arr_ref

    RParen          reduce using rule 4 (empty -> .)
    Identifier      shift and go to state 17
    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Integer         shift and go to state 38
    LParen          shift and go to state 36

    opt_expression                 shift and go to state 168
    expression                     shift and go to state 113
    empty                          shift and go to state 122
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    arr_ref                        shift and go to state 21
    logical_or                     shift and go to state 22
    logical_and                    shift and go to state 23
    bit_or                         shift and go to state 24
    xor                            shift and go to state 25
    bit_and                        shift and go to state 26
    equality                       shift and go to state 27
    relational                     shift and go to state 28
    additive                       shift and go to state 29
    multiplicative                 shift and go to state 30
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 37

state 163

    (23) statement_matched -> Do statement_matched While LParen expression RParen . Semi

    Semi            shift and go to state 169


state 164

    (24) statement_unmatched -> Do statement_unmatched While LParen expression RParen . Semi

    Semi            shift and go to state 170


state 165

    (14) statement_matched -> If LParen expression RParen statement_matched Else statement_matched .

    RBrace          reduce using rule 14 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    If              reduce using rule 14 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    While           reduce using rule 14 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    For             reduce using rule 14 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Do              reduce using rule 14 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Return          reduce using rule 14 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    LBrace          reduce using rule 14 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Break           reduce using rule 14 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Continue        reduce using rule 14 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Int             reduce using rule 14 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Identifier      reduce using rule 14 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Minus           reduce using rule 14 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    BitNot          reduce using rule 14 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Not             reduce using rule 14 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Integer         reduce using rule 14 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    LParen          reduce using rule 14 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Semi            reduce using rule 14 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Else            reduce using rule 14 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)


state 166

    (15) statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .

    RBrace          reduce using rule 15 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    If              reduce using rule 15 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    While           reduce using rule 15 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    For             reduce using rule 15 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Do              reduce using rule 15 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Return          reduce using rule 15 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    LBrace          reduce using rule 15 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Break           reduce using rule 15 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Continue        reduce using rule 15 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Int             reduce using rule 15 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Identifier      reduce using rule 15 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Minus           reduce using rule 15 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    BitNot          reduce using rule 15 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Not             reduce using rule 15 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Integer         reduce using rule 15 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    LParen          reduce using rule 15 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Semi            reduce using rule 15 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)


state 167

    (19) statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression . RParen statement_matched
    (21) statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression . RParen statement_unmatched

    RParen          shift and go to state 171


state 168

    (20) statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression . RParen statement_matched
    (22) statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression . RParen statement_unmatched

    RParen          shift and go to state 172


state 169

    (23) statement_matched -> Do statement_matched While LParen expression RParen Semi .

    RBrace          reduce using rule 23 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    If              reduce using rule 23 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    While           reduce using rule 23 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    For             reduce using rule 23 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Do              reduce using rule 23 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Return          reduce using rule 23 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    LBrace          reduce using rule 23 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Break           reduce using rule 23 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Continue        reduce using rule 23 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Int             reduce using rule 23 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Identifier      reduce using rule 23 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Minus           reduce using rule 23 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    BitNot          reduce using rule 23 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Not             reduce using rule 23 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Integer         reduce using rule 23 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    LParen          reduce using rule 23 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Semi            reduce using rule 23 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Else            reduce using rule 23 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)


state 170

    (24) statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .

    RBrace          reduce using rule 24 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    If              reduce using rule 24 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    While           reduce using rule 24 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    For             reduce using rule 24 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Do              reduce using rule 24 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Return          reduce using rule 24 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    LBrace          reduce using rule 24 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Break           reduce using rule 24 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Continue        reduce using rule 24 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Int             reduce using rule 24 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Identifier      reduce using rule 24 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Minus           reduce using rule 24 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    BitNot          reduce using rule 24 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Not             reduce using rule 24 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Integer         reduce using rule 24 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    LParen          reduce using rule 24 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Semi            reduce using rule 24 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)


state 171

    (19) statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen . statement_matched
    (21) statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen . statement_unmatched
    (14) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (17) statement_matched -> . While LParen expression RParen statement_matched
    (19) statement_matched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
    (20) statement_matched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched
    (23) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (25) statement_matched -> . Return expression Semi
    (26) statement_matched -> . opt_expression Semi
    (27) statement_matched -> . LBrace block RBrace
    (28) statement_matched -> . Break Semi
    (29) statement_matched -> . Continue Semi
    (15) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (16) statement_unmatched -> . If LParen expression RParen statement
    (18) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (21) statement_unmatched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched
    (22) statement_unmatched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched
    (24) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (30) opt_expression -> . expression
    (31) opt_expression -> . empty
    (44) expression -> . assignment
    (4) empty -> .
    (45) assignment -> . conditional
    (64) assignment -> . Identifier Assign expression
    (65) assignment -> . arr_ref Assign expression
    (46) conditional -> . logical_or
    (82) conditional -> . logical_or Question expression Colon conditional
    (63) arr_ref -> . Identifier arr_idx_list
    (47) logical_or -> . logical_and
    (66) logical_or -> . logical_or Or logical_and
    (48) logical_and -> . bit_or
    (67) logical_and -> . logical_and And bit_or
    (49) bit_or -> . xor
    (68) bit_or -> . bit_or BitOr xor
    (50) xor -> . bit_and
    (69) xor -> . xor Xor bit_and
    (51) bit_and -> . equality
    (70) bit_and -> . bit_and BitAnd equality
    (52) equality -> . relational
    (71) equality -> . equality NotEqual relational
    (72) equality -> . equality Equal relational
    (53) relational -> . additive
    (73) relational -> . relational Less additive
    (74) relational -> . relational Greater additive
    (75) relational -> . relational LessEqual additive
    (76) relational -> . relational GreaterEqual additive
    (54) additive -> . multiplicative
    (77) additive -> . additive Plus multiplicative
    (78) additive -> . additive Minus multiplicative
    (55) multiplicative -> . unary
    (79) multiplicative -> . multiplicative Mul unary
    (80) multiplicative -> . multiplicative Div unary
    (81) multiplicative -> . multiplicative Mod unary
    (56) unary -> . postfix
    (58) unary -> . Minus unary
    (59) unary -> . BitNot unary
    (60) unary -> . Not unary
    (37) postfix -> . Identifier LParen call_para RParen
    (57) postfix -> . primary
    (83) primary -> . Integer
    (84) primary -> . Identifier
    (85) primary -> . LParen expression RParen
    (86) primary -> . arr_ref

    If              shift and go to state 114
    While           shift and go to state 115
    For             shift and go to state 116
    Do              shift and go to state 118
    Return          shift and go to state 119
    LBrace          shift and go to state 106
    Break           shift and go to state 120
    Continue        shift and go to state 121
    Semi            reduce using rule 4 (empty -> .)
    Identifier      shift and go to state 17
    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Integer         shift and go to state 38
    LParen          shift and go to state 36

    opt_expression                 shift and go to state 117
    statement_matched              shift and go to state 173
    statement_unmatched            shift and go to state 174
    expression                     shift and go to state 113
    empty                          shift and go to state 122
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    arr_ref                        shift and go to state 21
    logical_or                     shift and go to state 22
    logical_and                    shift and go to state 23
    bit_or                         shift and go to state 24
    xor                            shift and go to state 25
    bit_and                        shift and go to state 26
    equality                       shift and go to state 27
    relational                     shift and go to state 28
    additive                       shift and go to state 29
    multiplicative                 shift and go to state 30
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 37

state 172

    (20) statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen . statement_matched
    (22) statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen . statement_unmatched
    (14) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (17) statement_matched -> . While LParen expression RParen statement_matched
    (19) statement_matched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
    (20) statement_matched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched
    (23) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (25) statement_matched -> . Return expression Semi
    (26) statement_matched -> . opt_expression Semi
    (27) statement_matched -> . LBrace block RBrace
    (28) statement_matched -> . Break Semi
    (29) statement_matched -> . Continue Semi
    (15) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (16) statement_unmatched -> . If LParen expression RParen statement
    (18) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (21) statement_unmatched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched
    (22) statement_unmatched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched
    (24) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (30) opt_expression -> . expression
    (31) opt_expression -> . empty
    (44) expression -> . assignment
    (4) empty -> .
    (45) assignment -> . conditional
    (64) assignment -> . Identifier Assign expression
    (65) assignment -> . arr_ref Assign expression
    (46) conditional -> . logical_or
    (82) conditional -> . logical_or Question expression Colon conditional
    (63) arr_ref -> . Identifier arr_idx_list
    (47) logical_or -> . logical_and
    (66) logical_or -> . logical_or Or logical_and
    (48) logical_and -> . bit_or
    (67) logical_and -> . logical_and And bit_or
    (49) bit_or -> . xor
    (68) bit_or -> . bit_or BitOr xor
    (50) xor -> . bit_and
    (69) xor -> . xor Xor bit_and
    (51) bit_and -> . equality
    (70) bit_and -> . bit_and BitAnd equality
    (52) equality -> . relational
    (71) equality -> . equality NotEqual relational
    (72) equality -> . equality Equal relational
    (53) relational -> . additive
    (73) relational -> . relational Less additive
    (74) relational -> . relational Greater additive
    (75) relational -> . relational LessEqual additive
    (76) relational -> . relational GreaterEqual additive
    (54) additive -> . multiplicative
    (77) additive -> . additive Plus multiplicative
    (78) additive -> . additive Minus multiplicative
    (55) multiplicative -> . unary
    (79) multiplicative -> . multiplicative Mul unary
    (80) multiplicative -> . multiplicative Div unary
    (81) multiplicative -> . multiplicative Mod unary
    (56) unary -> . postfix
    (58) unary -> . Minus unary
    (59) unary -> . BitNot unary
    (60) unary -> . Not unary
    (37) postfix -> . Identifier LParen call_para RParen
    (57) postfix -> . primary
    (83) primary -> . Integer
    (84) primary -> . Identifier
    (85) primary -> . LParen expression RParen
    (86) primary -> . arr_ref

    If              shift and go to state 114
    While           shift and go to state 115
    For             shift and go to state 116
    Do              shift and go to state 118
    Return          shift and go to state 119
    LBrace          shift and go to state 106
    Break           shift and go to state 120
    Continue        shift and go to state 121
    Semi            reduce using rule 4 (empty -> .)
    Identifier      shift and go to state 17
    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Integer         shift and go to state 38
    LParen          shift and go to state 36

    opt_expression                 shift and go to state 117
    statement_matched              shift and go to state 175
    statement_unmatched            shift and go to state 176
    expression                     shift and go to state 113
    empty                          shift and go to state 122
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    arr_ref                        shift and go to state 21
    logical_or                     shift and go to state 22
    logical_and                    shift and go to state 23
    bit_or                         shift and go to state 24
    xor                            shift and go to state 25
    bit_and                        shift and go to state 26
    equality                       shift and go to state 27
    relational                     shift and go to state 28
    additive                       shift and go to state 29
    multiplicative                 shift and go to state 30
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 37

state 173

    (19) statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .

    RBrace          reduce using rule 19 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    If              reduce using rule 19 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    While           reduce using rule 19 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    For             reduce using rule 19 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    Do              reduce using rule 19 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    Return          reduce using rule 19 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    LBrace          reduce using rule 19 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    Break           reduce using rule 19 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    Continue        reduce using rule 19 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    Int             reduce using rule 19 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    Identifier      reduce using rule 19 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    Minus           reduce using rule 19 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    BitNot          reduce using rule 19 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    Not             reduce using rule 19 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    Integer         reduce using rule 19 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    LParen          reduce using rule 19 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    Semi            reduce using rule 19 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    Else            reduce using rule 19 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)


state 174

    (21) statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .

    RBrace          reduce using rule 21 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    If              reduce using rule 21 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    While           reduce using rule 21 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    For             reduce using rule 21 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Do              reduce using rule 21 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Return          reduce using rule 21 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    LBrace          reduce using rule 21 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Break           reduce using rule 21 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Continue        reduce using rule 21 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Int             reduce using rule 21 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Identifier      reduce using rule 21 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Minus           reduce using rule 21 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    BitNot          reduce using rule 21 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Not             reduce using rule 21 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Integer         reduce using rule 21 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    LParen          reduce using rule 21 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Semi            reduce using rule 21 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)


state 175

    (20) statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .

    RBrace          reduce using rule 20 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    If              reduce using rule 20 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    While           reduce using rule 20 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    For             reduce using rule 20 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    Do              reduce using rule 20 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    Return          reduce using rule 20 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    LBrace          reduce using rule 20 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    Break           reduce using rule 20 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    Continue        reduce using rule 20 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    Int             reduce using rule 20 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    Identifier      reduce using rule 20 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    Minus           reduce using rule 20 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    BitNot          reduce using rule 20 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    Not             reduce using rule 20 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    Integer         reduce using rule 20 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    LParen          reduce using rule 20 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    Semi            reduce using rule 20 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    Else            reduce using rule 20 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)


state 176

    (22) statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched .

    RBrace          reduce using rule 22 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    If              reduce using rule 22 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    While           reduce using rule 22 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    For             reduce using rule 22 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Do              reduce using rule 22 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Return          reduce using rule 22 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    LBrace          reduce using rule 22 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Break           reduce using rule 22 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Continue        reduce using rule 22 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Int             reduce using rule 22 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Identifier      reduce using rule 22 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Minus           reduce using rule 22 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    BitNot          reduce using rule 22 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Not             reduce using rule 22 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Integer         reduce using rule 22 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    LParen          reduce using rule 22 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Semi            reduce using rule 22 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for Int in state 7 resolved as shift
WARNING: shift/reduce conflict for Comma in state 73 resolved as shift
WARNING: shift/reduce conflict for Comma in state 123 resolved as shift
